[{"body":"为什么学习 Emacs Emacs 是一个文本编辑器系列，包含有多个分支，其中最主流的一支是 GNU Emacs，大多数情况下所说的 Emacs 都是指 GNU Emacs，本教程也使用 Emacs 指代 GNU Emacs。Emacs 这一名字最早来源于 “Editor MACroS”，后来也有人称它集合了五个主要功能键的首字母 Esc、Meta、Alt、Ctrl、Shift。\nEmacs 与 Vi 共同被称为最古老的 Unix 编辑器，一代代程序员对 Emacs 和 Vi （尤其后来出现的 Vim）产生了无休止的争论。Emacs 诞生已有近五十年时间，是世界上最古老而依然活跃（截止 2021 年）的开源软件之一。\nEmacs 的主要思路是大量依赖组合快捷键实现高效编辑，这直接导致了想要流畅使用 Emacs 必须要记忆 Emacs 的大量快捷键，需要相当一段时间熟悉。此外，Emacs 编辑器本身所使用的编程语言是 Emacs Lisp 语言，Lisp 语言的方言之一。Lisp 语言是诞生于 1958 年的世上第二古老高级程序设计语言，其语言以“列表”（List）作为语法和核心数据结构，由于其具备强大的宏系统，可以创造各式方言，Emacs Lisp 就是其中之一。这个语言相对于我们常见的编程语言来说，晦涩难懂，同样增加了 Emacs 的学习难度。网上流传着一个有趣的形容各个编辑器学习曲线的图片：\n那么，既然如此，为什么要学习这个难以学习的编辑器呢？就为了高效+全面+高度定制化。\n高效：Emacs 将快捷键使用到极致，凡事都尽可能使用快捷键来解决。这样一来，程序员需要记忆繁多的快捷键，但一旦形成了肌肉记忆，将能得到极高的效率。笔者根据自己的体验，在熟练使用 Emacs 的快捷键后，使用任何常规编辑器都会觉得效率低下。即使是使用如 Visual Studio Code 或 JetBrains IDE 系列辅以 Emacs 键位，由于其功能不全，体验也很差。 全面：除了基本的编辑功能，可以与其它各种工具相结合，完成编译、调试、版本管理等各类开发任务，可以说如果你想，可以将它打造为一个功能强大的 IDE。 可扩展与定制化：事实上极强的可扩展性才是我认为的 Emacs 最核心的竞争力，前面两个优势归根结底也都是可扩展性带来的优点。与其它号称高可扩展性的编辑器相比，Emacs 内核几乎没有因为安全因素等考虑对用户产生任何限制，因此没有什么是在 Emacs 中扩展不出来的。网络上有着非常大量的 Emacs 插件可供自由搭配选择，你很难想到一个需求是别人没有解决过的，更有大量的功能是你不接触 Emacs 可能永远想不到的。你可以根据你的需求安装插件，而不必安装你不需要的功能，最终你的 Emacs 会是为你自己高度定制化的一个编辑器。Emacs 插件涉及的功能非常广泛，一种调侃 Emacs 的说法是，Emacs 不是一个编辑器，而是一个操作系统，其中甚至有一些游戏、还能让 Emacs 成为一个功能完整的浏览器。下图是一个 xkcd 网站上的漫画 Real Programmers，调侃了 Emacs 可以让蝴蝶扇动翅膀，利用蝴蝶效应引发内存上的一个比特翻转，由此来进行编程，表现了 Emacs 功能的丰富。此外，你可以使用 Emacs Lisp 进行编程，实现你独特的需求。 特别的，在 Linux/macOS 系统的终端中，是可以使用部分 Emacs 快捷键的；在 macOS 系统中的各种文本编辑框，如备忘录、浏览器搜索框等等也都支持 Emacs 光标移动快捷键。因此可以说，掌握 Emacs 快捷键，在各种操作系统中都可以享受到其带来的方便快捷。\nEmacs 的主要相关资料 Emacs 主页：可在此下载安装包，还有文档、Wiki 等的入口。\nEmacs 官方文档：最准确、最全面。有能力可以直接按照官方文档进行学习。\nEmacs Wiki：关于 Emacs 插件、Emacs Lisp 的一些使用方法。\nEmacs Lisp 教程：Emacs Lisp 的完整教程。\nEmacs StackExchange 问答论坛：Emacs 的 StackExchange，有着大量关于 Emacs 的提问和精品回答。\nEmacs Reference Card：即 Emacs 备忘表（Cheatsheet）。前两个 PDF 是基本内容，基本操作卡片和“生存卡片”。\n对 Vim 用户 Emacs 有一个 evil 插件可以在 Emacs 中直接使用 Vim 的快捷键，这对 Vim 转 Emacs 用户而言非常友好，降低了转换成本。所以我们常能在社区看到许多 Vim 转 Emacs 的用户。此外，对于不想花过多时间配置的读者，可以使用下一小节中提到的 “Emacs 发行版”。\n其它 Emacs 本教程所讨论的 GNU Emacs 是最原始的 Emacs，需要从 0 开始配置。部分用户会觉得这样过于枯燥，于是有一些 “Emacs 发行版”，预装了很多插件。这样的 Emacs 有两个：Doom Emacs 和 Spacemacs，它们尤其对 Vim 转到 Emacs 的用户比较友好，因为它们预装了 evil 插件，可以在 Emacs 上使用 Vi 的操作。但本文只讲解原生 Emacs，也被称为 Vanilla Emacs。\n此外还有一个专门适配 macOS 的 Aquamacs，对 macOS 的一些特点进行了适配，例如用 Cmd+O 来替代 C-x C-f 打开文件。但笔者更偏爱 GNU Emacs，毕竟它在所有平台上的操作方式都是一致的。\n","link":"https://pavinberg.github.io/emacs-book/zh/intro/","section":"","title":"入门介绍"},{"body":"为什么要再写一篇 Emacs 入门教程，网上的资料不是很多吗？笔者的感受是：在中文社区中，关于 Emacs 的资料质量并不高，大部分的 Emacs 教程，开篇开始教各种快捷键，让你练习如何移动光标、打开文件等等，但是这些教程时常没有下文——不完整；同时它不告诉你 Emacs 的运作逻辑、基本思想——不系统；对插件的推荐更是一句带过不去解释——不耐心。\n本教程是面向中文社区的、旨在提供系统性完整的学习流程的 Emacs 教程。因此本教程的相比于基础的操作细节，更侧重于讲述一些底层逻辑，包括少量 Emacs Lisp 编程知识。这样如果出了问题读者可以知道该去搜索什么关键词，哪里有可能找到答案。此外，本教程会尽可能涉及较广泛的配置和插件介绍，让初学者能够在一开始就知道有这样或那样的插件存在和配置方法，形成一套完整可用的工作流程，而避免受到一些浅薄的教程的误导。\n但本教程做不到的是囊括 Emacs 的所有功能，否则几乎等于把 Emacs 文档全抄一遍。笔者希望能通过本教程给读者指出一条学习道路，能够在之后自主地根据自身需要去学习更多 Emacs 的使用方法。\n最后，为避免无意义的争论，在此说明：本文将会介绍 Emacs 的入门知识，并与此同时展示 Emacs 的一些优点。但本文无意与其它编辑器进行好坏对比，不涉及任何争论。\n你需要做到 本教程的读者总的来说，应当是喜爱钻研、富有耐心、对计算机学科较为热爱的人群。学习 Emacs 是一个漫长的过程，需要大量的练习和积累，需要耐心进行配置、解决出现的问题，这些就要求了读者应当是相关从业人员或爱好者，平日需要写许多的代码，并有一定的专业基础。这就是为什么本教程叫“专业”入门。\n尽管在一篇编辑器的教程中抬高学习门槛并不恰当，但笔者认为 Emacs 的学习难度较大，还是希望读者至少会一门编程语言的基础部分，并且在未来能保持一定的代码量，从而能不断训练使用 Emacs 的技巧。\n如果读者无法满足上述条件，笔者不建议学习 Emacs，还有很多其它编辑器可供选择。\n那么，现在我们开始吧!\n开始教程 ","link":"https://pavinberg.github.io/emacs-book/zh/","section":"","title":"专业 Emacs 入门"},{"body":"本篇介绍 GNU Emacs 的基础知识和操作。本文内容只是让读者初识 Emacs 操作，这些操作需要日积月累的练习才能掌握，本文的后半部分更偏向用于日后查阅；另一方面，很多操作有些繁琐难以记忆，笔者将会在后续介绍一些插件能够极大改善这些问题，因此读者如果遇到晦涩的地方不必过分担心，也不用死记硬背。\n文章的结尾附上了本文出现的快捷键及其命令名，供读者查阅。\n另外不要忘了官网的 Emacs Reference Card：即 Emacs 备忘表（Cheatsheet）。前两个 PDF 是基本内容，一个是基本操作卡片，另一个是更为简洁的“生存卡片”。可以打印出来放在一边。\n安装 截止本文更新日期（2022.4.6）Emacs 的稳定版本为 28.2。建议使用新一些的版本，最好是 Emacs 26 以上，因为一些插件需要 Emacs 更高版本的支持。\n特别的，Emacs 28 版本新增使用 GCC JIT 对 Emacs Lisp 字节码的执行进行加速，可以显著提高 Emacs 的运行速度。推荐大家安装最新的版本。\n图形界面在官网下载安装包进行安装。\n此外还可以用正常包管理工具来进行安装。\nmacOS:\n1$ brew install emacs Debian/Ubuntu:\n1$ sudo apt-get install emacs 稍老一些的 Ubuntu 可能不能直接这样安装最新版本的 Emacs，需要自行去下载最新版本安装包安装。\n其它系统类似，安装操作网上资源较多，在此不做赘述。\n启动 图形界面可以直接打开程序。命令行输入命令启动 Emacs。\n1$ emacs 如果想要打开非图形界面版的 Emacs，输入：\n1$ emacs -nw # no window system 如果后面接文件名，则可以直接打开相应文件。\n启动后可以看到这样的界面，可以看到其中有一个 \u0026quot;Emacs tutorial\u0026quot;，如果读者英文不错，可以直接点击进入，进行互动入门教程，跳过本篇教程。\n对于 macOS，如果是用安装包手动安装的，直接输入 emacs 命令无法启动图形界面程序，也可以在命令行里添加一个 alias：\n1alias emacsx=\u0026#34;open -a /Applications/Emacs.app/ $1\u0026#34; 之后就可以用 emacsx 命令启动图形界面了。当然，读者可以换成更短的名字，比如 emx。但其实还是推荐用 Homebrew Cask 来安装。\n退出程序的方法请见最后的附录。\n关于键盘操作 为什么大量使用快捷键？\nEmacs 作为一个在图形界面诞生之前就存在的编辑器，其打设计之初就根本不需要鼠标来进行操作，那么直到今天，真正流畅的编程其实也最好不要引入过多的鼠标操作，越是常用的操作就应当更多地使用键盘而不是使用鼠标。鼠标是低效的，读者可以把手放到键盘上正常打字的位置，如果你现在忽然要使用鼠标来进行文本的选择，那右手（对于大部分人来说）就要立刻拿开，摸到鼠标、找到光标、移动到合适的位置、微调鼠标定位、选中、手放回原位。这么长的操作只是为了选中那么一点文字，而这又是如此常见的需求，这种操作模式会打断码代码的手部连贯性和头脑思绪的连贯性。\n快捷键的出现就是用来弥补这一不足，通过简短的按键来完成一些复杂的任务。而 Emacs 一不做二不休，直接将快捷键用到极致——所有操作都最好用快捷键。这样一来，程序员会比较辛苦，需要记忆繁多的快捷键，但一旦形成了肌肉记忆，将能得到极高的效率。\n需要提前说明的是，快捷键是一个十分自由的配置，你可以根据你自己的需要任意修改，笔者会给出一些笔者实践中的经验，但读者不必也不需要完全仿照，一切根据自己的习惯和需求来。\n功能键 Emacs 中有五个功能键： Control、 Meta、 Shift、 Super、 Hyper。其中部分名称读者可能不熟悉，那是几十年前的键盘上的按键名称，其中的 Hyper 键更是在现代键盘上消失了。那 Meta 和 Super 又是什么呢？ Meta 对应于普通 PC 键盘上的 Alt 键，Mac 电脑上的 Option 键。 Super 对应 PC 键盘上的 Win 键，对应 Mac 电脑上的 Command 键。那么我们知道， Super 键在现代系统中起到了重要作用，因此 Emacs 平常不使用和 Super 键相关的快捷键，Emacs 的绝大多数快捷键都是使用 Control 和 Meta 键，而其中一大部分都是只使用 Control 键。\n尽管 Hyper 键已经消失了，但是 Emacs 依然可以使用这个功能键，例如如果读者手上的键盘有一些不常用的按键，可以考虑设定为 Hyper 键，拓宽快捷键，这部分读者自行探索吧。 事实上 Emacs 中也有 Alt 键，但现在键盘上的 Alt 键都是被映射为 Meta，Alt 键也几乎不去使用了，为避免混淆就没有放到正文中介绍。 可以看到， Control 键是 Emacs 程序员键盘的“重灾区”，按 Control 键的小指也是 Emacs 程序员最易出问题的部位，因此笔者强烈建议，在你正式使用 Emacs 后改变键盘键位保护手指。 例如笔者将 Control 键改到了大小写锁定键上（读者可以调换两个键，但考虑到实际很少用大小写锁定键，笔者索性不要大小写锁定键了）。也可以将 PC 键盘上的 Win 键、Mac 键盘上 的 Command 键与 Control 调换，这样使用强壮的大拇指也没有问题。如果不想全局改变，也可以只在 Emacs 内部进行，后面会提到。 笔者作为 Mac 用户，推荐一款改键软件 Karabiner-Elements，它甚至可以将 Emacs 常用键位完全拓展到全局。 在 Emacs 中，我们经常需要自定义快捷键，那么需要一种方式来表示快捷键，这样才能写到配置文件里。Emacs 使用一个单独的字母表达功能键，见下表。\nEmacs 功能键 缩写 对应键盘按键(PC/Mac) Control C Ctrl / Control Meta M Alt / Option Shift S Shift / Shift Super s Win / Command Hyper H 无 Emacs 用连字符表示“同时按下”。例如，我们用 C-a 表达“先按下 Control 键不要松，再按下 a 键“。 C-x b 则表达“先按下 Control 键不松，按下 x 键，松开这两个键，按下 b 键”。\nC-S-\u0026lt;mouse-1\u0026gt; 表达“同时按下 Control 键和 Shift 键，然后鼠标左键点击“。这里提到了鼠标是因为 Emacs 图形界面支持鼠标操作，并且在有些场景下的确使用鼠标更为方便（例如无规律的多光标选择）。\n特别的， Meta 键做前缀有两种按法，例如 M-x 可以“按住 Meta 键不要松，再按下 x 键“，也可以“先按一下 Esc 键松开，再按一下 x 键“。后者是为了在应对无法使用 Meta 键的硬件或系统，但实际操作有很多不便。因此读者尽可能使用 Alt / Option 作为 Meta 键来按。\n一些终端例如 Mac 自带的终端默认不会把 Option 键作为 Meta 传入，但只需打开它的偏好设置，其中 ”Profiles - Keyboard“ 中有一项“将 Option 用作 Meta 键“，勾选即可。iTerm2 同理。 Emacs 命令 在介绍具体的快捷键之前，要先说明 Emacs 的主体逻辑。与其它编辑器类似，Emacs 也是通过命令进行交互的。而所谓命令，就是 Emacs 中使用 Elisp 语言定义的一些函数。这些函数可以完成一些功能。例如，即使是最最简单的“将光标上移一行”，也对应着命令 previous-line 。一切操作都对应一个命令，而快捷键的本质是在调用这些命令。\n对 Emacs 输入命令需要先按下 M-x，此时你会看到 Emacs 最下面的空行上出现了 \u0026quot;M-x \u0026quot;，然后等待你的输入，随后你便可以输入一个函数名。这一快捷键可以说是最重要的一个快捷键了，只要有它，即使你忘记了其它快捷键，也可以输入函数名进行调用。\n命令名的传统是有连字符连接的多个有意义的英文单词。在输入时可以用空格代替连字符。也可以使用 \u0026lt;tab\u0026gt; 键自动补全。\n自然， M-x 也对应着命令 execute-extended-command。 基础快捷键 接下来介绍一些入门基础内容。读者最好打开一个文本进行尝试，例如前面提到的 Emacs 内置教程，如果不知如何打开，请按下 C-h t （注意松开 Control 键和 h 键之后再按 t 键）。或者读者打开任意一段代码。\n对于 Vim 用户，可以安装 evil 插件来使用 Vim 按键，可略读下文的大部分内容。 插件的安装方式请参考基本配置和插件：功能增强类的最后一节。 如何退出 退出程序： C-x C-c。\n对于输了一半的命令，或者按了一部分快捷键但不想继续了，可以按下 C-g 放弃。此外在任何场合如果出现了卡住等情况，也都可以尝试输入 C-g 打断。\n光标移动 光标移动也需要教？是的，Emacs 快捷键甚至连方向键都绑定了快捷键。如此大费周章是由于方向键在键盘上处于非常偏的位置，按方向键时你的右手需要做移动，而按方向键又是常见操作，Emacs 认为这种程度的手部移动就已经在打断写代码的连贯性了！\n于是，方向键上下左右的快捷键是 C-p、 C-n、 C-b、 C-f。它们的英文含义分别是：previous（前）、next（后）、back（退）、forward（进）。一开始看的确很奇怪，但熟练之后确实方便顺手。\n除此之外，Emacs 提供了多种方式进行光标移动：\n以词为单位： M-b 光标向左移动一个词， M-f 光标向右移动一个词。 首尾： 行： C-a 光标移至行首， C-e 光标移至行尾。而代码经常是有缩进的，但 C-a 会直接移动到整个行首，并不能直接编辑开头的文字，这种情况可使用 M-m 来移动到文字的开头。不过这里只是介绍，笔者之后会直接推荐一个插件 mwim，避免这个琐碎的小区别。 句子： M-a 光标移至句首， M-e 光标移至句尾。 整个文件： M-\u0026lt; 移动到文件开头， M-\u0026gt; 移动到文件末尾。注意这里需要同时按下 Meta 键、 Shift 键和逗号/句号键。 窗口：M-r 按第一次——光标移动到窗口中间行；接着按第二次——光标移动到窗口最上面一行；接着按第三次——光标移动到窗口最下面一行。 笔者平日使用 mac 电脑，macOS 本身就有着近乎全局的这套 Emacs 快捷键，因此笔者平日很少按方向键，全部使用这四个快捷键。读者需要大量练习，形成肌肉记忆。\n如果想增加一些趣味性，可以玩 Emacs 内的贪吃蛇游戏来锻炼对方向键的熟练度。按 M-` 调用 tmm-menubar，按 t 选择 Tools，按 g 选择 Games，按 s 选择 Snake，然后开始游戏吧！ 编辑操作 删除字符：删除一个字符与正常一样，按下删除键（在 Emacs 中删除键写为 \u0026lt;DEL\u0026gt; 或 \u0026lt;backspace\u0026gt;）即可删掉光标左侧的字符。如果想要删掉右侧的字符，就按下 C-d 键。 移除词：M-d 移除光标右边一整个词。M-\u0026lt;DEL\u0026gt; 移除光标左侧一整个词。 移除右侧直到句子结尾： M-k。 移除右侧直到行结尾： C-k 。 选中部分区域（region）：把光标移动到某处，按下 C-SPC （ SPC 表示空格键，space），此时 Emacs 最下方的空行显示 “Mark set“，表示当前打了一个标；接着任意移动光标到另一个位置，可以看到半透明的选择框。这就是和平日里你使用鼠标进行选择是一样的。 复制： M-w 复制选中的区域。 移除： C-w 移除选中的区域。 注意，这里我用了“删除”和“移除“两种说法，”删除“对应于 \u0026quot;delete\u0026quot;，是真的删除，而“移除”对应于 \u0026quot;kill\u0026quot;，相当于“剪切”，之后可以再次插入到其它位置，即 \u0026quot;insert\u0026quot;，相当于粘贴。\n笔者的实际使用中，复制比移除更为常见，由于光标的移动等大量操作依赖于 Control 键，因此将复制与移除调换，使用 C-w 做复制，M-w 做移除更为顺手。读者可以根据自己的需要更改，具体配置方法见后续教程。 Emacs 内部维护了一个环形“剪贴板历史”，当你想插入之前移除的内容时（即粘贴之前剪切的内容），按下 C-y，这被称为 \u0026quot;yank\u0026quot;，它会将最近一次移除的内容插入回来。那么如何粘贴历史记录呢？在一次 \u0026quot;yank\u0026quot; 的基础上，再按 M-y ，就可以得到倒数第二次移除的内容，再按一次 M-y 即可得到倒数第三次移除的内容，以此类推。后面笔者会介绍插件 counsel 辅助这个过程。\n撤销（undo）： C-/ 或 C-_ 或 C-x u。撤销刚刚的操作。对字符进行编辑例外，例如你按了 5 次删除键删除了 5 个字符，按一下撤销即可复原。 重做（redo）：Emacs 对于历史记录也维护成了一个环。但 Emacs 并没有直接的重做操作，而是先按一下 C-g ，即没有操作，此时再按撤销键时，会撤销上次的“撤销”，相当于重做；也可以理解为按下 C-g 后这个环的移动方向会改变。所以 Emacs 其实不分 undo 和 redo，而是靠改变历史记录的移动方向来控制。那么读者一定觉得这里难以理解不便使用，没错，因此笔者将会在后面介绍更好用的插件 undo-tree。 标记与跳转 上文提到的选中键 C-SPC 不仅是选中文本这么简单的功能，它的本质是设定一个标记（mark）。Emacs 还有一个标记跳转功能，例如我们先在文本的第一行，按下两次 C-SPC（这样我们即打了标记，又没有选中文本），然后光标移动到别的位置（甚至以后学过之后，到别的文件），这时候按下 C-x C-SPC 或 C-u C-SPC，即可立刻跳转回刚刚的位置。同样的，有更好用的插件可以辅助这一功能即上文提到的 counsel。\n想要跳到特定的行，M-g M-g 加行号、回车即可 。\n重复操作 Emacs 提供了一个机制可以把一个命令重复执行任意次数。具体来说，先按下 C-u，再按数字表示次数，再按下命令的快捷键。例如：C-u 12 C-n 表示向下 12 行。如果不加数字，默认是 4 次。\n注意，有些特殊命令不表示次数，例如与 M-x 组合时表示传参。读者暂不需要知晓这么深刻。 页面移动 C-v 会向下翻滚一页内容， M-v 会向上翻滚一页。但 Emacs 会保留三行不会被翻过去，这样看起来更为舒服。\nC-l 第一次按时，会移动页面使得光标所在行在窗口中央。这样当我们写文本写到下面时，只需要按一下 C-l 即可把当前光标所在行移动到正中央，有利于查看。但如果按完一次之后紧接着再按一次 C-l，会移动页面使得光标所在行在窗口最上面，而按第三次 C-l 会移动页面使得光标所在行在窗口最下面。第四次按与按一次的效果相同，如此循环。\n搜索文本 从光标位置向下搜索，按下 C-s，即 search，此时最下方空行会出现 \u0026quot;I-search: \u0026quot;，输入你要搜索 的文本，此时会显示出能够匹配的文本，光标会移动到第一个匹配的文本位置。\n如果你想让光标跳到下一个匹配位置，就再按一次 C-s。 如果想停留在当前位置，退出搜索，按下回车键。 如果想放弃搜索，回到搜索前的位置，按下 C-g。 从光标位置向前搜索，按下 C-r，其用法与 C-s 一致，只是方向相反。安装了 swiper 的话会显示搜索结果列表，更为直观（swiper 和上文提到的 counsel 是一套插件）。\n其它小操作 交换光标左右的字符：C-t ；交换光标前后的词：M-t；交换光标所在行和上一行：C-x C-t。还有交换句子、段落、选择区域等，但没有快捷键，详见文档。 在光标所在行下方创建一个新的空行：C-o；将光标所在前后所有连续空行变为一个空行：C-x C-o。 将光标后一词变为小写：M-l；变为大写 ：M-u；变为首字母大写：M-c。\n获得帮助 Emacs 内置了多种获取帮助的方式。其共有前缀 C-h。\n简要描述快捷键功能：按下 C-h c 后，按想查询的快捷键。例如 C-h c C-p，会在最下面出现：\u0026quot;C-p runs the command previous-line\u0026quot;，告诉你 C-p 键对应的命令是 \u0026quot;previous-line\u0026quot;。 详细描述快捷键功能：按下 C-h k 后，按想查询的快捷键。 描述函数（function）： C-h f，输入函数名。 描述变量（variable）： C-h v，输入变量名。 列出含某一关键词的命令（Command Apropos）： C-h a，加一个关键词。 列出含某一关键词的符号的文档： C-h d，加一个关键词。 这些帮助太多了记不住？还有帮助的帮助：\nC-h ?，列出以上功能，以及其它帮助功能。\n有一个小插件 which-key 可以在敲快捷键给予一定的提示作用，后续会详细介绍。\n一些系统对有些键位会做映射。例如 macOS 就会将 C-/ 映射为 C-_ ， C-SPC 映射为 C-@。不影响日常使用，但是读者想覆盖键位时需要注意。 命令列表 操作描述 快捷键 命令名 输入命令 M-x execute-extended-command 退出程序 C-x C-c save-buffers-kill-terminal 放弃当前输入 C-g keyboard-quit 光标向上一行（方向键上） C-p previous-line 光标向下一行（方向键下） C-n next-line 光标向左一个字符（方向键左） C-b backward-char 光标向右一个字符（方向键右） C-f forward-char 光标向左移动一个词 M-b backward-word 光标向右移动一个词 M-f forward-word 光标移至行首 C-a move-beginning-of-line 光标移至行尾 C-e move-end-of-line 光标移动到一行缩进的开头 M-m back-to-indentation 光标移至句首 M-a backward-sentence 光标移至句尾 M-e forward-sentence 光标移至文件开头 M-\u0026lt; beginning-of-buffer 光标移至文件结尾 M-\u0026gt; end-of-buffer 光标移动至窗口的中间、最上、最下 M-r move-to-window-line-top-bottom 删除光标右侧字符 C-d delete-char 移除光标右侧词 M-d kill-word 移除光标左侧词 M- backward-kill-word 移除右侧直到句子结尾 M-k kill-sentence 移除右侧直到行尾 C-k kill-line 设置标记以选择区域 C-SPC set-mark-command 复制区域 M-w kill-region-save 移除区域 C-w kill-region 插入已移除文本 C-y yank 插入历史移除文本 M-y yank-pop 撤回 C-/ 或 C-_ 或 C-x u undo 跳转到上一标记 C-x C-SPC 或 C-u C-SPC pop-global-mark 跳转到行号 M-g M-g goto-line 重复 C-u universal-argument 向下一页 C-v scroll-up-command 向上一页 M-v scroll-down-command 移动页面使得光标在中央/最上方/最下方 C-l recenter-top-bottom 向后搜索 C-s isearch-forward 向前搜索 C-r isearch-backward 交换前后字符 C-t transpose-chars 交换前后词 M-t transpose-words 交换前后两行 C-x C-t transpose-lines 在下方新建一行 C-o open-line 删除连续空行为一个空行 C-x C-o delete-blank-lines 将后面的词变为小写 M-l downcase-word 将后面的词变为大写 M-u upcase-word 将后面的词变为首字母大写 M-c capitalize-word 放大字号 C-x C-= text-scale-adjust 缩小字号 C-x C-- text-scale-adjust 重置字号 C-x C-0 text-scale-adjust 简要描述快捷键功能 C-h c describe-key-briefly 描述快捷键功能 C-h k describe-key 描述函数功能 C-h f describe-function 描述变量 C-h v describe-variable 列出含某一关键词的命令 C-h a apropos-command 列出含某一关键词的符号的文档 C-h d apropos-documentation 帮助的帮助 C-h ? help-for-help ","link":"https://pavinberg.github.io/emacs-book/zh/basic/","section":"","title":"基础操作"},{"body":"本篇介绍 Emacs 的界面术语、如何管理多个文件，如何分割显示等等。同样的，本文更多介绍概念，具体操作起来是有插件可以方便我们进行操作的。结尾的附录包含了本文涉及的所有快捷键。\n初识界面 首先我们需要了解 Emacs 界面的一些术语。了解术语更多是为了在网上搜资料、看文档、配置时能够更准确地抓住关键。\nFrame：如果用图形界面打开 Emacs 程序，那么一整个程序窗口被称为 Frame，如果打开了多个窗口就有多个 Frame；如果在终端内打开 Emacs，那么 Emacs 所占据的整个终端的界面被称为 Frame。上图都是一个 Frame。\nMenu bar：即菜单栏，在 Frame 的最上方。默认包括了 File、Edit……等等下拉菜单。在终端中不能用鼠标时，需要用 menu-bar-open 命令打开，对应快捷键 \u0026lt;f10\u0026gt; 。此外还有一个 M-` 键（对应命令 tmm-menu）可以从下方展开互动界面打开菜单。\nTool bar：即工具栏。只在图形界面时可以使用，就是上面第二张图中那一些图标。由于它十分丑陋且功能又很基本，在上一篇教程中已完全涉及，所以正常笔者会关掉工具栏——在配置文件中加入代码 (tool-bar-mode -1) （如何编辑配置文件将在后续教程中详细介绍）。\nEcho Area：整个界面下方的一行就是“回显区”，用以打印各种简短的信息。例如上面第二张图就打印了如果你想获取帮助就按 C-h C-a，上一篇教程中也提及了这一命令。\nWindow：Tool bar 以下（如果有）、Echo area 以上这一整个区域，就是 Window，即窗口。 可以看到 Emacs 的窗口和我们日常使用电脑所说的窗口不是一个东西，一定要注意，不然在配置、调用命令或者在网上搜索信息时会搞错。我们日常称为窗口的在 Emacs 中被称为 Frame，而 Frame 内的核心区域才被称为 Window。\nMode line：Window 最下方灰色的一行即为“模式行”（即显示 -UUU:%%--F1 GNU Emacs 的部分）。这里会显示当前 Buffer 的一些信息（什么是 Buffer 见下文）大概包括了文件编码、是否修改、当前 Buffer 名、光标所在位置占全文百分比、行号（L1 表示第一行）等等。它的内容可以自定义，也可以使用 smart-mode-line 插件进行管理，后文将会更多介绍。\nScroll bar：图形界面时 Window 的最右侧有一滚动条。事实上在 Emacs 中根本不需要用滚动条，所以笔者也直接关闭了它，让界面更清爽，在配置中加入 (when (display-graphic-p) (toggle-scroll-bar -1)) 表示在是用图形界面时关闭滚动条。\nCursor：光标。光标是一个 1 字符宽的方块，但其真正表达的位置是其左侧的长边，即两字符之间。文档中有一些关于其显示效果的设置，例如可以换成大家日常更习惯的小竖线（bar），但其实笔者觉得还是方块（box）比较显眼，看习惯也挺好。\nPoint：光标所在的位置称为 Point。区别于光标的是，光标有且只有一个，但 Point 是针对 Buffer 的，每个 Buffer 都有一个 Point。许多命令的触发都要读取 Point 信息。\n文件与 Buffer 前面多次提到的 Buffer 到底是什么呢？接下来我们通过打开多个文件来展现 Buffer 的作用。\n打开多文件 之前我们是在命令行中使用 emacs \u0026lt;filename\u0026gt; 的方式来打开文件。而想要在 Emacs 内打开一个文件，按下 C-x C-f（ find-file ），此时 Echo area 会出现 “Find file: “，后面为一个路径，输入文件对应的路径即可打开相应文件。如果想新建文件，只需要输入一个不存在的文件名即可。输入时可以使用 键自动补全，就和 Linux 中类似。插件 ivy 或 helm 可以辅助这一过程，后面详细介绍。\n保存文件对应命令 C-x C-s。\n开文件并只读不改：C-x C-r。 打开另一相近文件：C-x C-v，此时下面的路径会自动以当前文件全名作为初始路径（而不是目录的路径），这样方便稍微修改一些文件名打开另一文件。 已打开的文件切换为只读模式：C-x C-q。 Emacs 可以打开多个文件，同样使用 C-x C-f 打开即可。 但是你如果打开了第二个文件，便会发现第一个文件就消失不见了，应当去哪里找呢？事实上，所有打开的文件都会被放入一个被称为 Buffer 的对象中，当打开了第二个文件时，第一个文件所在的 Buffer 会切入后台，而第二个文件的 Buffer 会占据当前的 Window。Buffer 的名字显示在 Mode line 中间，通常是文件名本身。\nEmacs 也可以用这个方式打开目录（文件夹），会显示出目录内的文件（此即 Linux 的设计理念，一切皆为文件，即使是目录也本质上是一个文件），可以用光标选择想打开的文件。\nBuffer 的切换 切换 Buffer 有三类方法，简短的方法是使用 C-x b，输入 Buffer 的名字后按回车即可切换。 Echo area 中会提示你，如果什么也不输直接按回车，可以跳转到当前默认的 Buffer 中，这样方便在两个文件中来回切换。\n显然这样如果 Buffer 多了会记不住名字也不便于管理，于是可以使用第二个方法，C-x C-b，此时会弹出一个 Window，名为 \u0026quot;Buffer List\u0026quot; ，列出了当前所打开的所有 Buffer。其中可以看到多个以星号（*） 开头结尾的 Buffer，那些都是 Emacs 用于输出一些信息的 Buffer，并不是由于打开文件而产生。例如 “Messages” 是 Emacs 的一些输出信息。“scratch” 是可以编写一些 Elisp 代码的地方。Buffer 开头如果是 %，表示这个 Buffer 被修改过而没有保存。\n如果当前光标没有在 \u0026quot;Buffer List\u0026quot; 中可以用 C-x o 键切换过去。 可以通过光标选择切换到某个 Buffer。同时在这个 \u0026quot;Buffer List\u0026quot; 中有很多功能可以使用。按问号（?）可以显示帮助。常见的操作例如 q 退出， d 标记一个 Buffer 打算关闭，s 标记一个 Buffer 打算保存，u 取消标记，x 执行刚刚标记过的删除和保存操作。事实上，在这里上下移动光标也不需要 C-p 和 C-n，直接按 p 和 n 即可。\n想要关闭当前的 Buffer？直接在当前的 Buffer 处按下 C-x k 即可。\n此外，第三种方法是使用 C-mouse-1 （mouse-1 表示鼠标左键）然后用鼠标菜单切换 Buffer 。\n事实上，在输入 M-x 后、C-x b 后在 Echo area 显示的等待输入的区域被称为 Minibuffer， 所以它们的输入方式是共通的，都可以用相同的补全机制等。 文件备份 使用 Emacs 打开文件后，会发现目录下会多一个和打开的文件同名但是后面多了个 ~ 字符的文件，例如打开了 names.txt 后会出现 names.txt~， 这是 Emacs 的备份机制，防止程序或系统崩溃，或是用户误操作破坏了文件。可以设置关闭或文件数量上限等等，详见文档。（关闭备份需要设置：(setq make-backup-files nil)）。\n多 Window 想要同时打开两个文件相互参照对比是一个再常见不过的需求了，Emacs 自然可以做到。\nC-x 2 ：上下分割出两个 Window。 C-x 3：左右分割出两个 Window。 C-x 0：关闭光标所在处的 Window。 C-x 1：只保留光标所在处的 Window，关闭其它 Window。其它 Window 的 Buffer 依然没有关闭，可以通过 \u0026quot;Buffer List\u0026quot; 查看。 C-x o：将光标切换到下一个 Window。 分割后，默认会把当前的 Buffer 也显示到新的 Window，即显示了两个一样的 Window。再次强调一下，Buffer 对应真正打开的文件，而 Window 是把 Buffer 显示出来的元件，所以一个文件只会开一个 Buffer，但可以有多个 Window 显示。于是，在新的 Window 里用 C-x C-f 打开另一个文件即可看到两个文件了，当然也可以正常用上面所说的 Buffer 切换。\n那么既然开一个新的窗口并打开新的文件这个需求很常见，对此如果只有以上快捷键，需要先 C-x 3 分割出一个窗口，C-x o 切换到新窗口，C-x C-f 打开新文件，过于繁琐。所以 Emacs 提供了一个快捷键：\nC-x 4 f 来达到“在另一个窗口打开新的文件，如果只有一个窗口就分割成两个”的效果。\n此外，还有 C-x 4 b 表示“在另一个窗口切换到另一 Buffer，如果只有一个窗口就分割成两个” 。C-x 4 d 表示 “在另一个窗口打开目录，如果只有一个窗口就分割成两个”。\n可以总结出 C-x 4 为前缀时，就表达“在另一个窗口做……“。\n在打开两个窗口时，如果我们光标在第一个窗口，而希望第二个窗口翻页，那么就可以用 C-M-v 向下翻页。用 C-M-S-v （同时按下 Control，Meta， Shift 和 v）向上翻页。\n那么如果在已经分割之后再分割呢？Emacs 会继续做二等分，变成 3 个、4 个等窗口。此时窗口的切换和关闭就没有那么方便了。插件 ace-window 可以辅助这一过程，后面详细介绍。\n多 Frame 既然能多 Window，自然能多个 Frame。打开一个新的 Frame 可以使用快捷键 C-x 5 2； 在一个新的 Frame 打开文件，可以使用快捷键 C-x 5 f。C-x 5 和 C-x 4 基本类似，只是前者在 Frame 间操作，后者在 Window 间操作。\n笔者的日常使用中，对多文件的打开更偏爱在单个 Frame 中用多个 Window，很少在多 Frame 中间频繁切换。\n模式（mode） Emacs 的核心要素之一就是模式（mode）。一个模式就对应着一组环境，不同模式可以分别进行配置，应对不同的场景。例如，编写 C++ 代码时就对应 c++-mode，编写 Python时使用 python-mode。在不同的语言的 mode 中，编译、执行的方式都是不同的，这样只要事先定义好 mode，就可以在使用过程中方便切换各种需求场景。\nEmacs mode 分两类，主模式（Major mode）和次模式（Minor mode）。\n主模式 主模式默认根据 Buffer 的文件类型来选择，一个 Buffer 只能对应一个主模式。例如，Emacs 发现你打开了 .cpp 为后缀的文件，就会把 Buffer 自动设置成 c++-mode，发现你打开了 .py 后缀的文件，就把相应 Buffer 自动设置为 python-mode，最直观的区别是 Emacs 为不同语言的源码提供了不同的语法高亮。 主模式的名字会显示在 Mode line 上。\n我们也可以手动切换主模式，只需要按下 M-x ，输入相应的模式名称即可。通常来说其实我们不需要手动设置。\n最基本的主模式是 Fundamental mode，就是没有进行任何配置的模式 。 次模式 同一个 Buffer 可以有多个次模式，次模式可以进一步调整、增加一些配置。通常来说，插件都是靠次模式来起作用的。当我们安装插件时，插件的官网会提示如何设置这个插件，其中大多都会使用次模式。\n官网中列出了一些常用次模式。下一篇教程的配置中，笔者会直接列出其中常用的几个是如何设置的。\nMode hook 每一个主模式都对应着一个 Mode hook，hook 是挂钩的意思，Mode hook 的作用就是当启动一个主模式时，自动执行一些已经“挂钩”到这个主模式的函数或次模式。由此，我们可以自由地向一个主模式上挂上各种功能，在启动这个主模式时就可以自动跟随着一起启动。\nMode hook 的名字通常就是“主模式名-hook”。例如，我们希望在主模式“文本文件模式” text-mode 时启动次模式“检查拼写” flyspell-mode ，我们就可以这样写配置：\n(add-hook 'text-mode-hook 'flyspell-mode) 这样当我们打开 txt 文件时，会自动开启检查拼写功能。\ntext-mode 是基于文本的文件的一个主模式，有一些其它主模式是由它派生，例如 html-mode。而相对的，还有编程模式 prog-mode，各种编程语言对应的主模式都是由它派生，包括我们上文提到的 c++-mode 和 python-mode。那么如果我们希望在任何编程语言时都有一些共同需要的功能，例如编程时我们希望有代码块折叠功能，就为 prog-mode-hook 挂上相应功能就好。\n1(add-hook \u0026#39;prog-mode-hook #\u0026#39;hs-minor-mode) 在下一篇教程中，我们会进一步讨论这些应该如何配置更好。\n目录（文件夹）操作 Dired，即 Directory Editor，是 Emacs 自带的用以处理目录和文件的功能。常见的操作例如删除文件、将文件从一处拷贝至另一处，更高级的操作如对比两个文件的异同、更改权限、链接文件等等，都可以通过 Dired 实现。\n启动 Dired 非常简单，只需要按下 C-x C-f，输入一个目录（文件夹）而非文件，就会进入 Dired。更标准的方式是按 C-x d 或调用 M-x dired 命令然后输入一个目录的名字启动，但前者与打开文件的快捷键相同，更易记忆。\n当已经打开了一个文件时，输入 C-x C-j 可以打开当前文件所在的目录。\nDired 会把目录下的文件都列出来，随后用户可以对文件进行操作。此时可以按下 h （Help）来打开帮助，读者可以翻到下面的 \u0026quot;Keybindings\u0026quot;，里面列出了所有在 Dired 中可以使用的命令。\nDired 基本操作逻辑为，通过光标上下移动（此时不需要按 Control 而直接按 p 和 n 就可以上下移动光标）到相应文件上，按下一个命令快捷键来对该文件调用命令。想要批量操作，只需要按 m （Mark）就可以选择，按 u（Unmark） 来取消选择。批量删除时，按 d（Delete）标记删除，按 x（Execute）执行删除。\n可以执行的命令全都在 \u0026quot;Keybindings\u0026quot; 中罗列，读者只需要自行查阅即可。\n这里举一个简单的例子，我们想要将 a.txt 和 b.txt 文件挪到 subdir 中，首先我们可以对 subdir 按下 i 来展开这个子目录， 随后对两个文本文件按下 m 标记， 然后按下 R（Rename） ，在回显区输入 ~/Code/Emacs/Test/subdir/，按下回车。\n这里熟悉 Linux 的读者应该清楚， 移动文件的本质就是重命名（Rename），所以 Dired 里没有所谓的”移动“这个操作，而只有重命名。 总结 以上内容介绍了 Emacs 界面的术语，如何打开多个文件，如何在多个 Buffer 之间切换和如何使用多个 Window 和 Frame。希望读者多进行尝试，感受一下细节。如果熟练掌握到现在为止的内容，读者应当可以满足编辑文本方面的基本需求了。\n命令列表 操作描述 快捷键 命令名 下拉菜单栏 menu-bar-open 互动菜单栏 M-` tmm-menubar 打开文件 C-x C-f find-file 保存文件 C-x C-s save-buffer 打开并只读文件 C-x C-r find-file-read-only 打开另一相近文件 C-x C-v find-alternate-file 只读模式 C-x C-q read-only-mode 切换到 Buffer C-x b switch-to-buffer 列出 Buffer C-x C-b list-buffers 关闭 Buffer C-x k kill-buffer 鼠标列出 Buffer C-mouse-1 mouse-buffer-menu 上下分割出 Window C-x 2 split-window-below 左右分割出 Window C-x 3 split-window-right 关闭当前 Window C-x 0 delete-window 只保留当前 Window C-x 1 delete-other-windows 切换到另一 Window C-x o other-window 在另一 Window 中打开文件 C-x 4 f find-file-other-window 在另一 Window 中切换 Buffer C-x 4 b switch-to-buffer-other-window 在另一 Window 中打开目录 C-x 4 d dired-other-window 创建新的 Frame C-x 5 2 make-frame-command 在另一 Frame 中打开文件 C-x 5 f find-file-other-frame 让另一 Window 向下翻页 C-M-v scroll-other-window 让另一 Window 向上翻页 C-M-S-v scroll-other-window-down ","link":"https://pavinberg.github.io/emacs-book/zh/buffer/","section":"","title":"多文件与模式"},{"body":"本篇介绍配置 Emacs 相关的知识和操作。本文主要内容归纳：\n简单的 Emacs Lisp 语言知识——让你在配置时游刃有余 配置文件的知识——模块化的写法 一些观点——最好不要完全使用并依赖大牛的配置，把配置掌握在自己手中 一些基础配置——开启部分 Emacs 功能 介绍插件的安装并用 use-package 管理插件——管理成本低、逻辑更清晰 快捷键、变量的设置——迈出你的自定义脚步 Emacs Lisp 简介 为什么要了解 Emacs Lisp Emacs Lisp 是世界上第二古老高级编程语言 Lisp 专为 Emacs 打造的方言。官方提供了 Emacs Lisp 的入门介绍和参考手册。简单来说 Emacs Lisp 编程语言就是用来为 Emacs 编写逻辑，Emacs 的底层和绝大部分插件都是用这个语言写出来的。同时，作为用户，我们也可以使用 Emacs Lisp 编写一些自定义逻辑，甚至进一步形成插件。\n学习一门语言自然是比较麻烦的，但完全不必紧张，事实上绝大部分情况我们都不需要自己写 Emacs Lisp，基本上你想要的需求都可以在网上搜索到其他人已经写好的代码，至多只需要微调一下。为了应对这种需要微调的情况，同时也加强对 Emacs 的掌控，我们简单了解一下 Emacs Lisp 的语法。\n当然读者如果确实不想在这件事上耗费时间精力，可以跳到下一节直接了解“配置文件”。\n语法简介 以下语法介绍为了便于理解存在一些简化和不是百分百准确的类比。最终以文档为准。\nEmacs Lisp 对于大部分人来说是十分陌生的，其语法看着就十分古怪。以下是一个例子（来源于 ivy 插件）：\n1(defun ivy-set-prompt (caller prompt-fn) 2 (setq ivy--prompts-list 3 (plist-put ivy--prompts-list caller prompt-fn))) Emacs Lisp 发源于 Lisp，而 Lisp 就是 “List Processing“ 的缩写，顾名思义，Lisp 语言的核心就是列表（List）。在 Lisp 中，每一对小括号表达了一个列表，列表元素用空格分隔。在执行 Lisp 时，会把列表的第一个元素作为函数名，后面的元素都是函数的参数。元素可以是一个“词”，也可以是另一个列表。可以类比 Shell 命令的写法，也是第一个词是命令名，而后面的是命令的参数。\n例如，2+3+4 在 Lisp 中写为：\n1(+ 2 3 4) 因为 + 就是个函数，后面是它的参数。 再如 4+(3-2) 写为：\n1(+ 4 (- 3 2)) 那么在 Emacs 中基本都是做一些定义函数、变量等操作的 ，定义函数就用 defun 关键字， 设置变量的值用 setq 关键字。\n所以上面展示的那段 Emacs Lisp 代码可以约等于如下 C/C++ 语言代码（类型名是笔者杜撰的）：\n1void ivy_set_prompt(CallerType caller, FnType prompt_fn) { 2 ivy__prompts_list = plist_put(ivy__prompts_list, caller, prompt_fn); 3} 约等于如下 Python 代码：\n1def ivy_set_prompt(caller, prompt_fn): 2 ivy__prompts_list = plist_put(ivy__prompts_list, caller, prompt_fn) 注意这里笔者把所有的连字符替换成了下划线。这里就可以看出，Lisp 的变量名、函数名要比 C/C++、Python、Java 等主流语言的变量名的要求更宽松，Lisp 的变量名可以包含许多字符，所以如果看到了一些奇奇怪怪的名字，不要感到惊讶，就是变量名。\n还有一些常见关键字如 let 为一组变量圈出一个作用域、if / when / unless 表示条件语句。 t 表示 true，nil 表示空（相当于 C 语言的 NULL、Python 的 None）。\n另外有一些不起眼的字符在 Lisp 中也是有意义的，例如单引号表达了后面的元素不进行执行而直接返回它本身：\n1\u0026#39;(Tom Amy John) 当括号前面有一个单引号时，表达了一个包含了三个元素的“数组”，而不是在执行一个叫 Tom 的函数。而\n1\u0026#39;ivy-set-prompt 表示把 ivy-set-prompt 这个函数作为一个对象传递给其它部分，也没有执行这个函数。\n反引号（`）backquote（或称 backtick、grave accent）在 Lisp 中也有含义，和单引号类似，读者只需要知道有这回事就好，基本上不需要我们去编写这些内容。 Emacs Lisp 源码文件的后缀名是 .el。\n分号（;）以后的内容都是注释。\n由于 Lisp 的整个语言结构就是列表的嵌套，所以它设定了一个非常强大的宏系统，可以用代码生成代码，甚至定义出一个与之前不太一样的新语言，常被称为方言。Emacs Lisp 就是这样诞生的。再加上其变量名可使用的字符很多，所以读者如果发现了一些不同寻常的写法，例如下文提到的 use-package，不要觉得惊讶，也请记住 Lisp 的语法本质始终都是列表。\n配置文件\n在介绍了 Emacs Lisp 的基本语法后，我们来正式开始学习 Emacs 的配置相关的知识。\n配置文件是一个包含了 Emacs Lisp 源码的文件，描述了 Emacs 应当以什么样的方式启动。在 Emacs 启动的时候会执行其中的代码，可以理解为启动时刻运行的脚本。\n当启动 Emacs 时，Emacs 会自动依次寻找以下几个文件之一作为配置文件：\n~/.emacs ~/.emacs.el ~/.emacs.d/init.el ~/.config/emacs/init.el 如果想用其它位置的自定义配置文件详见文档。 可以预见，随着我们需要的功能越来越复杂，配置源码会越来越长，我们会希望能够分多个源文件进行不同功能的管理。所以使用 ~/.emacs.d/init.el 作为配置文件是最为常见的。 我们可以将其它各种源文件都放置在 ~/.emacs.d 目录下，方便管理。\n基础设置 现成的配置 读者如果阅读过其它 Emacs 相关建议，一定见过很多人建议初学者直接使用一些 Emacs 大牛的配置。笔者的观点是大牛的配置自然要借鉴，但一定要慢慢学习大体了解其中的内容，不能盲目地使用，否则想要改配置的时候就不知所措了。\n笔者在最开始其实是完全自己配置的，虽然比较辛苦也走过很多弯路，但倒也是一个学习的过程。\n笔者最开始借鉴的就是 Steve Purcell 的配置。Steve Purcell 是 MELPA 的维护者（MELPA 是什么下文将会介绍）。读者可以 clone 下来后把文件夹命名为 ~/.emacs.d，之后启动 Emacs 时会自动安装 Steve Purcell 配好的插件。\n笔者作为一个代码强迫症患者，对于这种“不知道它给我安装了什么插件”的情况感到十分不快，所以我会进行自己的修改。之后的教程会尽可能介绍如何去配置、用到了什么插件。笔者会借鉴一部分 Steve Purcell 的配置来为大家讲解，读者可以在 Steve Purcell 的配置基础上自己修改，也可以从零开始一步步按照笔者的说明来进行探索。\n基本结构 首先，请使用 Emacs 打开 ~/.emacs.d/init.el 文件。一开始如果没有这个文件，我们创建它就好。\n根据 Emacs Lisp 的规范，所有的源码文件的开头最好写好 docstring，也就是一些关于这个文件的说明，即使是 init.el 也不例外。以 Steve Purcell 的 init.el 为例：\n1;;; init.el --- Load the full configuration -*- lexical-binding: t -*- 2;;; Commentary: 3 4;; This file bootstraps the configuration, which is divided into 5;; a number of other files. 6 7;;; Code: 按照习惯，三个分号开头的注释表示“节”，两个分号开头的注释表示“段落”。（一个分号开头的是一行代码后面的行内注释）。;;; Code: 后面就开始 Emacs Lisp 的代码了。同时，文件的结尾要是：\n1;;; init.el ends here Steve Purcell 的配置的前 34 行几乎可以照抄，除了其中一行 (require 'init-benchmarking)中使用了他定义在 ~/.emacs.d/lisp/init_benchmarking.el 中的逻辑来测量启动时间，读者酌情加入 ：\n1(let ((minver \u0026#34;25.1\u0026#34;)) 2 (when (version\u0026lt; emacs-version minver) 3 (error \u0026#34;Your Emacs is too old -- this config requires v%s or higher\u0026#34; minver))) 4(when (version\u0026lt; emacs-version \u0026#34;26.1\u0026#34;) 5 (message \u0026#34;Your Emacs is old, and some functionality in this config will be disabled. Please upgrade if possible.\u0026#34;)) 6 7(add-to-list \u0026#39;load-path (expand-file-name \u0026#34;lisp\u0026#34; user-emacs-directory)) ; 设定源码加载路径 8;; (require \u0026#39;init-benchmarking) ;; Measure startup time 9 10(defconst *spell-check-support-enabled* nil) ;; Enable with t if you prefer 11(defconst *is-a-mac* (eq system-type \u0026#39;darwin)) 12 13;; Adjust garbage collection thresholds during startup, and thereafter 14 15(let ((normal-gc-cons-threshold (* 20 1024 1024)) 16 (init-gc-cons-threshold (* 128 1024 1024))) 17 (setq gc-cons-threshold init-gc-cons-threshold) 18 (add-hook \u0026#39;emacs-startup-hook 19 (lambda () (setq gc-cons-threshold normal-gc-cons-threshold)))) 涉及一些基本的启动要素，例如检查版本、设定源码加载路径、通过修改垃圾回收的内存上限来提高 Emacs 启动速度等等。其中，“设定源码加载路径” 这句代码是指将 ~/.emacs.d/lisp/ 目录作为源码加载路径，这样你可以将功能需求拆分成多个文件放置在这个目录中，供 init.el 使用。\n那么拆分出去的功能怎么使用呢？如果你使用的是 Steve Purcell 的配置，可以看到许多的 (require 'xxx)，这个可以理解为“导入并执行”，基本类似于 Python 的 import。 也就是导入刚刚说的放置在了 ~/.emacs.d/lisp/ 目录下的某个源码文件，并运行了其中的代码使得内部的设置和函数定义生效。\n举个例子，我们可以创建一个文件 ~/.emacs.d/lisp/hello.el，包含如下代码：\n1;;; hello -- Echo \u0026#34;Hello, world!\u0026#34; 2;;; Commentary: 3;;; Code: 4 5(defun hello-world () 6 (interactive) 7 (message \u0026#34;Hello, world!\u0026#34;)) 8 9(provide \u0026#39;hello) ; 意为“导出本模块，名为 hello”。这样就可以在其它地方进行 require 10 11;;; hello.el ends here 在 init.el 中，加上一句代码 (require 'hello)，重启 Emacs，此时 Emacs 就会多了一条名为 hello-world 的命令。读者此时可以按下 M-x，输入 hello-world，就可以看到回显区 Echo area 中出现了 \u0026quot;Hello, world!\u0026quot;。尽管这个函数不在 init.el 中定义，但通过这种方式导入就可以顺利执行成功！\n(interactive) 这句代码意为“让这个函数可以通过 M-x 手动调用，否则按下 M-x 时会发现找不到 hello-world 这个命令。 没有 (interactive) 的函数就是指不对用户直接暴露的函数，是用于内部调用的。 观察 Steve Purcell 的 init.el，几乎通篇都是 (require 'xxx)，这种模块化风格值得学习。\n最开始的配置 对于一个刚打开的“白板”编辑器来说，有不少功能是我们亟需开启的，在此做简要归纳：\n1(setq confirm-kill-emacs #\u0026#39;yes-or-no-p) ; 在关闭 Emacs 前询问是否确认关闭，防止误触 2(electric-pair-mode t) ; 自动补全括号 3(add-hook \u0026#39;prog-mode-hook #\u0026#39;show-paren-mode) ; 编程模式下，光标在括号上时高亮另一个括号 4(column-number-mode t) ; 在 Mode line 上显示列号 5(global-auto-revert-mode t) ; 当另一程序修改了文件时，让 Emacs 及时刷新 Buffer 6(delete-selection-mode t) ; 选中文本后输入文本会替换文本（更符合我们习惯了的其它编辑器的逻辑） 7(setq inhibit-startup-message t) ; 关闭启动 Emacs 时的欢迎界面 8(setq make-backup-files nil) ; 关闭文件自动备份 9(add-hook \u0026#39;prog-mode-hook #\u0026#39;hs-minor-mode) ; 编程模式下，可以折叠代码块 10(global-display-line-numbers-mode 1) ; 在 Window 显示行号 11(tool-bar-mode -1) ; （熟练后可选）关闭 Tool bar 12(when (display-graphic-p) (toggle-scroll-bar -1)) ; 图形界面时关闭滚动条 13 14(savehist-mode 1) ; （可选）打开 Buffer 历史记录保存 15(setq display-line-numbers-type \u0026#39;relative) ; （可选）显示相对行号 16(add-to-list \u0026#39;default-frame-alist \u0026#39;(width . 90)) ; （可选）设定启动图形界面时的初始 Frame 宽度（字符数） 17(add-to-list \u0026#39;default-frame-alist \u0026#39;(height . 55)) ; （可选）设定启动图形界面时的初始 Frame 高度（字符数） 配置快捷键 首先介绍一下如何配置全局的快捷键：\n1(global-set-key (kbd \u0026lt;KEY\u0026gt;) \u0026lt;FUNCTION\u0026gt;) 其中 \u0026lt;KEY\u0026gt; 和 \u0026lt;FUNCTION\u0026gt; 替换为你想要设置的快捷键和功能。例如一个常见设置是修改回车键为“新起一行并做缩进”：\n1(global-set-key (kbd \u0026#34;RET\u0026#34;) \u0026#39;newline-and-indent) 其它设置示例：\n1(global-set-key (kbd \u0026#34;M-w\u0026#34;) \u0026#39;kill-region) ; 交换 M-w 和 C-w，M-w 为剪切 2(global-set-key (kbd \u0026#34;C-w\u0026#34;) \u0026#39;kill-ring-save) ; 交换 M-w 和 C-w，C-w 为复制 3(global-set-key (kbd \u0026#34;C-a\u0026#34;) \u0026#39;back-to-indentation) ; 交换 C-a 和 M-m，C-a 为到缩进后的行首 4(global-set-key (kbd \u0026#34;M-m\u0026#34;) \u0026#39;move-beginning-of-line) ; 交换 C-a 和 M-m，M-m 为到真正的行首 5(global-set-key (kbd \u0026#34;C-c \u0026#39;\u0026#34;) \u0026#39;comment-or-uncomment-region) ; 为选中的代码加注释/去注释 6 7;; 自定义两个函数 8;; Faster move cursor 9(defun next-ten-lines() 10 \u0026#34;Move cursor to next 10 lines.\u0026#34; 11 (interactive) 12 (next-line 10)) 13 14(defun previous-ten-lines() 15 \u0026#34;Move cursor to previous 10 lines.\u0026#34; 16 (interactive) 17 (previous-line 10)) 18;; 绑定到快捷键 19(global-set-key (kbd \u0026#34;M-n\u0026#34;) \u0026#39;next-ten-lines) ; 光标向下移动 10 行 20(global-set-key (kbd \u0026#34;M-p\u0026#34;) \u0026#39;previous-ten-lines) ; 光标向上移动 10 行 读者使用 Emacs 期间应当已经发现规律，Emacs 的常见快捷键前缀是 C-x 和 C-c，笔者有一些个人操作：解绑本来的 C-j 快捷键（本来功能为 electric-newline-and-maybe-indent），让 C-j 也成为了一个前缀：\n1(global-set-key (kbd \u0026#34;C-j\u0026#34;) nil) 2;; 删去光标所在行（在图形界面时可以用 \u0026#34;C-S-\u0026lt;DEL\u0026gt;\u0026#34;，终端常会拦截这个按法) 3(global-set-key (kbd \u0026#34;C-j C-k\u0026#34;) \u0026#39;kill-whole-line) MELPA 那么插件从哪里安装呢？Emacs 的插件都被放在了一些固定的仓库网站上，就好像手机的应用商店一样，区别是 Emacs 所使用的仓库是可以自由配置的，我们只需要把仓库的地址告诉 Emacs 就可以了。Emacs 最大的插件仓库就是 MELPA 了，也就是上文提到的 Steve Purcell 所维护的项目。此外也有一个默认仓库 GNU ELPA。\nMELPA 的官网有直接介绍如何配置：\n1(require \u0026#39;package) 2(add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) t) 3(package-initialize) 只需这三行，就可以把仓库地址 https://melpa.org/packages/ 存储到 package-archives 列表中，并命名为 “melpa”。\n由于国内网络问题，直接访问速度较慢，有如下两个方案。\n使用代理 把下面的代码加在配置文件中，修改为自己的代理服务器 IP 和代理服务器端口号。\n1(setq gnutls-algorithm-priority \u0026#34;NORMAL:-VERS-TLS1.3\u0026#34;) ; 不加这一句可能有问题，建议读者尝试一下 2(setq url-proxy-services \u0026#39;((\u0026#34;no_proxy\u0026#34; . \u0026#34;^\\\\(192\\\\.168\\\\..*\\\\)\u0026#34;) 3 (\u0026#34;http\u0026#34; . \u0026#34;\u0026lt;代理 IP\u0026gt;:\u0026lt;代理端口号\u0026gt;\u0026#34;) 4\t(\u0026#34;https\u0026#34; . \u0026#34;\u0026lt;代理 IP\u0026gt;:\u0026lt;代理端口号\u0026gt;\u0026#34;))) 使用国内镜像 腾讯镜像：\n1(require \u0026#39;package) 2(setq package-archives \u0026#39;((\u0026#34;gnu\u0026#34; . \u0026#34;http://mirrors.cloud.tencent.com/elpa/gnu/\u0026#34;) 3 (\u0026#34;melpa\u0026#34; . \u0026#34;http://mirrors.cloud.tencent.com/elpa/melpa/\u0026#34;))) 4(package-initialize) 腾讯镜像中，除了 MELPA，第一条的 \u0026quot;gnu\u0026quot; 对应着的就是默认的 GNU ELPA，部分包是只在 GNU ELPA 上 的。这里的配置意为：设置了两个插件仓库，一个叫 gnu，一个叫 melpa。 还有一个清华镜像。但是这些镜像都停留在 2021 年，好像是上游哪里有问题。 随后重启 Emacs 后，输入命令 package-list-packages 就可以列出来仓库中的所有插件，可以选中相应的插件，会弹出介绍的界面和安装按钮。此外，还可以直接通过命令 package-install ，按下回车后，输入插件名就可以安装相应插件。\npackage-list-packages 列表界面下，可以按 h 显示帮助。在这个视图下可以批量操作，类似 Buffer List。例如可以按 U 检查所有已安装插件是否有新版本，如果有就会标注更新。按 i 可以标记想要安装。最后按下 x 就可以执行更新操作。 默认情况下，插件会被安装到 ~/.emacs.d/elpa/ 目录下。\n想要删除已安装的插件，输入命令 package-delete ，然后输入已安装的插件名即可。\n插件设置 (use-package) 通常各种插件都会发布到 GitHub 上，一般在上面都会介绍如何配置这个插件。但插件逐渐多了我们会发现，不同插件的使用、配置常常不同，一一配置会使得配置文件很乱，且不易管理，并且缺少一些自动化的配置机制。Steve Purcell 的配置中，他在 init-elpa.el 中定义了一些辅助函数 require-package 等实现了插件的自动安装。\n笔者则使用了一个更为方便的插件 use-package 来进行管理。\n首先安装 use-package。输入命令 package-install 按下回车后输入 \u0026quot;use-package\u0026quot;，回车。在 init.el 较靠前的位置（或其它你认为合适的文件中）写上：\n1(eval-when-compile 2 (require \u0026#39;use-package)) 这样，我们就在启动 Emacs 的时候首先加载 use-package 插件。随后我们再使用 use-package 插件来管理所有其它插件。\nuse-package 官网提供了一些教程，其使用方法很简单，假设我们希望使用一个叫 foo 的插件：\n1(use-package foo 2 :init ; 在加载插件前执行一些命令 3 (setq foo-variable t) 4 :config ; 在加载插件后执行一些命令 5 (foo-mode 1)) 所有的冒号开头的词是 use-package 的一些设置关键词。上面的代码表示使用名为 foo 的插件，在加载插件之前设置变量 foo-variable 为 t （即 true）。并在加载之后启动 foo-mode 。\n例如，我们在后面会介绍的一个 Emacs 补全功能增强插件 ivy，只需编写如下配置（这里只是示例，单纯粘贴此段代码会有报错，请查看后面的教程中更详细的说明）：\n1(use-package ivy 2 :ensure t ; 确认安装，如果没有安装过 ivy 就自动安装 3 :config ; 在加载插件后执行一些命令 4 (ivy-mode 1) ; 加载后启动 ivy-mode 5 (setq ivy-use-virtual-buffers t) ; 一些官网提供的固定配置 6 (setq ivy-count-format \u0026#34;(%d/%d) \u0026#34;) 7 :bind ; 以下为绑定快捷键 8 (\u0026#34;C-s\u0026#34; . \u0026#39;swiper-isearch) ; 绑定快捷键 C-s 为 swiper-search，替换原本的搜索功能 9 (\u0026#34;M-x\u0026#34; . \u0026#39;counsel-M-x) ; 使用 counsel 替换命令输入，给予更多提示 10 (\u0026#34;C-x C-f\u0026#34; . \u0026#39;counsel-find-file) ; 使用 counsel 做文件打开操作，给予更多提示 11 (\u0026#34;M-y\u0026#34; . \u0026#39;counsel-yank-pop) ; 使用 counsel 做历史剪贴板粘贴，可以展示历史 12 (\u0026#34;C-x b\u0026#34; . \u0026#39;ivy-switch-buffer) ; 使用 ivy 做 buffer 切换，给予更多提示 13 (\u0026#34;C-c v\u0026#34; . \u0026#39;ivy-push-view) ; 记录当前 buffer 的信息 14 (\u0026#34;C-c s\u0026#34; . \u0026#39;ivy-switch-view) ; 切换到记录过的 buffer 位置 15 (\u0026#34;C-c V\u0026#34; . \u0026#39;ivy-pop-view) ; 移除 buffer 记录 16 (\u0026#34;C-x C-SPC\u0026#34; . \u0026#39;counsel-mark-ring) ; 使用 counsel 记录 mark 的位置 17 (\u0026#34;\u0026lt;f1\u0026gt; f\u0026#34; . \u0026#39;counsel-describe-function) 18 (\u0026#34;\u0026lt;f1\u0026gt; v\u0026#34; . \u0026#39;counsel-describe-variable) 19 (\u0026#34;\u0026lt;f1\u0026gt; i\u0026#34; . \u0026#39;counsel-info-lookup-symbol)) 这样，所有有关 ivy 插件的配置就都整合在了一个 (use-package ...) 中，并且只需要加上 :ensure t 就可以检查安装情况、自动安装，十分方便管理。\n这里出现的语法看似和我们之前了解的不同，但其实本质一样。虽然 :ensure、:bind 等写法看起来好像很奇怪，但正如我们上文学到的，Lisp 的变量名十分灵活，且语言特性使得它具有非常强大的宏，可以自定义一些语法。use-package 就是自己设定了这样的一种写法。 此外，也可以轻松地设定上一篇教程中提到的模式的 hook。例如，我们希望在编程模式 prog-mode 下使用代码语法检查工具 flycheck，只需要使用 :hook 进行设置：\n1(use-package flycheck 2 :ensure t 3 :hook ; 为模式设置 hook 4 (prog-mode . flycheck-mode)) 配置变量 除了使用配置文件，Emacs 还提供了一个更为方便的办法管理一些变量（customizable variables），或称用户选项（user options）。\n最简单的进入办法，就是按下 M-x 输入 customize 后回车确认。\n变量是分组（group）管理的，只需要点进去寻找或搜索相关的变量就可以进行设置。对于每一个变量，点左侧的箭头展开内容，可以看到有的变量是 Toggle 按钮表示可以设定 true/false，有的则是取值列表，可以设定值。修改后，State 会显示已编辑。最后点击上方的 Apply 就是应用更改。点击 Revert 就可以放弃更改等。按 q 退出。\n当设置了变量后，事实上 Emacs 会自动将一些配置代码加入到 init.el 中，或是加入到自定义的文件中（比如 Steve Purcell 就自定义了这个文件）。\n此外，使用 Emacs 的过程中也可以临时修改某个变量的值，M-x set-variable 就可以输入变量名、回车、输入值、回车。还可以用 C-h v 输入变量名来查看变量的含义。\n因此总结来说，想要设定变量有三种途径：\n配置文件中使用 (setq name value) customize 中设定 运行过程中临时修改 M-x set-variable 最后笔者还想再强调一下，一定要区分好命令和变量 。这里笔者所指的”命令“是带有 (interactive) 的函数。例如上文举例的 hello-world 函数，这种函数可以通过 M-x 输入函数名调用，本教程姑且称之为“命令“。命令是可以执行的，而变量只是保存一个值，是不可执行的。在 Emacs Lisp 中二者的命名规则是一致的，看起来十分相似，对于初学者容易混淆。\n配置生效 最简单让配置生效的办法就是重启 Emacs。\n此外，如果你在频繁的改一些配置，尤其是调整一些参数等，频繁的重启很麻烦。事实上 Emacs Lisp 语言是逐句执行的。所以例如我们新加入了一段配置，我们便可以直接选中这部分代码，然后按下 M-x eval-region ，表达了“运行选中的这部分代码”的含义，这样这段代码立刻就会生效了。当然，还有 M-x eval-buffer 可以直接重新执行一下当前 Buffer 的所有代码。\n结尾 最后，配置文件的结尾要有一句：\n1(provide \u0026#39;init) 2 3;;; init.el ends here ","link":"https://pavinberg.github.io/emacs-book/zh/configurations/","section":"","title":"基本配置"},{"body":"接下来的部分，我们会开始介绍一些实用插件，让 Emacs 变得强大起来。在开始之前读者需要阅读完上一篇教程，知道如何进行 Emacs 的配置。\n由于插件数量众多，本教程将分类进行介绍。大体分为如下几类：\n功能优化类：对 Emacs 自身的一些不够完美的功能进行替换，解决一些痛点，提高操作便利性 功能增强类：大大提升 Emacs 体验与效率 编程类：和编程相关的插件配置 外观类：配置颜色、主题、屏保等。 值得一提的是，在众多插件中，其实相同的功能可能有好几个插件来实现，最典型的就是有两个知名度很高的插件做的是几乎同一件事。类比一下正如 Emacs 和 Vim、肯德基和麦当劳。本教程将重点介绍其中的一个笔者常使用的插件，对另一个插件（如果笔者了解的话）会做一点提及，读者可以自行进一步了解并根据自己的偏好进行选择。\n在这部分插件篇中，如果读者有除了文章中提到的插件以外的相关插件想要推荐给大家使用、对文章作出补充，欢迎在 Github 中提出 Pull Request。\n第一个插件笔者会详细介绍一下每一步的细节，后面的插件会逐步省略。\n本教程对插件的功能介绍大部分局限于核心功能，其它功能会省略，主要目的还是希望读者能抓住重点，不必劳烦记住所有繁琐的功能。在读者使用的过程中，可以自行探索插件的其它功能，一是可以查阅插件的文档，二是可以直接在 Emacs 内查看函数的文档。插件相关的命名都是会使用插件名作为前缀，例如马上要介绍的插件 ivy，和它相关的命令就都是 ivy-* 这样的命名。所以读者在安装 ivy 后可以首先 M-x ivy- 然后就可以看到一系列以此为前缀的命令，想要查询其中某一个的功能例如 ivy-push-view，那就先 C-g 回到正常 Buffer 内，然后输入我们第二篇教程就介绍的命令 C-h f ivy-push-view 就可以显示这个命令的介绍了。 ivy 简介 主页\n首先要介绍的当属 ivy 了。读者在前面使用 Emacs 时，可能多少会感到就像一开始使用 Linux 中的初始 shell Bash，功能是全的，但是使用的友好度差了点。ivy 就为 Emacs 带来了使用体验上的巨大提升，就好像用了 oh-my-zsh 的 zsh。\n打开 ivy 的链接，会发现其实这个仓库名为 swiper，里面包含了 ivy、counsel 和 swiper 三部分。它们三个分别加强了 Emacs 的三个方面： 补全系统 、 部分常用命令 、 搜索功能 。由于是作者 abo-abo（Oleh Krehel）开发的三个模块，现在都整合到了一起，我们一并安装就好。顺带一提的是，这位作者非常厉害，我们后面提到的好几个插件都由他发起和编写。\n配置流程 接下来，通过 ivy 来让读者熟悉一下 Emacs 安装插件的流程：\n得知插件 ：首先我们会通过一些渠道听说某个插件很好用（比如通过本系列教程），于是我们找到它的主页（绝大多数情况都是一个 GitHub 仓库，我们可以 Google 一下或者直接在 GitHub 上搜索）。 阅读主页 ：一个好用且用户数量大的插件的主页一定是非常完善的，包括了插件的功能介绍、安装、配置，以及 Issue （Issue 指使用中上报发现的问题和漏洞）和如何贡献等等。对于我们 Emacs 初级用户而言，我们主要关注前半部分，也就是功能、安装、配置。 安装 ：尽管该仓库包含了三部分，但它们都合并到了一个 package，也就是相当于是一个插件，名为 ivy。于是我们看 ivy的主页的 “Installation” 一节中写着： Install the ivy package from GNU ELPA or MELPA.\n很多插件都会用这样的一句话一笔带过安装方式。那么这就是对应了上一篇教程中提到的 MELPA 的相关内容了。根据上一篇的介绍，MELPA 是一个插件仓库，那么只要我们的配置文件中写好了相应的链接配置，就可以通过输入 M-x package-install \u0026lt;RET\u0026gt; ivy \u0026lt;RET\u0026gt; 来安装插件了。\n但此外，在上一篇教程中还提到了，我们有一个更方便的方式来管理插件—— use-package 插件。因此读者需要首先按照上一篇教程中的指导安装好 use-package 插件。于是我们可以直接在配置文件（例如 ~/.emacs.d/init.el）中写上：\n1(use-package ivy 2 :ensure t) 表示了希望确保 ivy 这个 package 已被安装，否则就下载安装 ivy。然后可以通过重启 Emacs 生效，或者直接运行这句刚加入的配置代码：首先选中要运行的这部分代码，然后输入 M-x eval-region ，或者光标在括号内时按下 C-M-x （eval-defun 执行函数）。之后 use-package 就会自动为你安装好 ivy。\n配置 ：主页上提供了完整的配置文档，同时也提供了一个简单的配置，那么一开始我们就直接使用它提供好的典型配置就好。但注意，它的写法是没有使用 use-package 的，有的插件会提供 use-package 的写法，而有的不会，这一点纯粹是依靠文档编写者的喜好。因此我们要填入我们自己的 use-package 中。事实上这个过程非常简单，我们首先看一下它提供的配置（笔者加入了一些注解）： 1;; ---- 执行了一个函数启动 ivy mode ---- 2(ivy-mode) 3;; ---- 设置两个变量为 True，还有一个可选的 --- 4(setq ivy-use-virtual-buffers t) 5(setq enable-recursive-minibuffers t) 6;; enable this if you want `swiper\u0026#39; to use it 7;; (setq search-default-mode #\u0026#39;char-fold-to-regexp) 8;; ---- 绑定快捷键 ---- 9(global-set-key \u0026#34;C-s\u0026#34; \u0026#39;swiper) 10(global-set-key (kbd \u0026#34;C-c C-r\u0026#34;) \u0026#39;ivy-resume) 11(global-set-key (kbd \u0026#34;\u0026lt;f6\u0026gt;\u0026#34;) \u0026#39;ivy-resume) 12(global-set-key (kbd \u0026#34;M-x\u0026#34;) \u0026#39;counsel-M-x) 13(global-set-key (kbd \u0026#34;C-x C-f\u0026#34;) \u0026#39;counsel-find-file) 14(global-set-key (kbd \u0026#34;\u0026lt;f1\u0026gt; f\u0026#34;) \u0026#39;counsel-describe-function) 15(global-set-key (kbd \u0026#34;\u0026lt;f1\u0026gt; v\u0026#34;) \u0026#39;counsel-describe-variable) 16(global-set-key (kbd \u0026#34;\u0026lt;f1\u0026gt; o\u0026#34;) \u0026#39;counsel-describe-symbol) 17(global-set-key (kbd \u0026#34;\u0026lt;f1\u0026gt; l\u0026#34;) \u0026#39;counsel-find-library) 18(global-set-key (kbd \u0026#34;\u0026lt;f2\u0026gt; i\u0026#34;) \u0026#39;counsel-info-lookup-symbol) 19(global-set-key (kbd \u0026#34;\u0026lt;f2\u0026gt; u\u0026#34;) \u0026#39;counsel-unicode-char) 20(global-set-key (kbd \u0026#34;C-c g\u0026#34;) \u0026#39;counsel-git) 21(global-set-key (kbd \u0026#34;C-c j\u0026#34;) \u0026#39;counsel-git-grep) 22(global-set-key (kbd \u0026#34;C-c k\u0026#34;) \u0026#39;counsel-ag) 23(global-set-key (kbd \u0026#34;C-x l\u0026#34;) \u0026#39;counsel-locate) 24(global-set-key (kbd \u0026#34;C-S-o\u0026#34;) \u0026#39;counsel-rhythmbox) 25(define-key minibuffer-local-map (kbd \u0026#34;C-r\u0026#34;) \u0026#39;counsel-minibuffer-history) 那么想要转移到 use-package ，只需要把这些代码根据逻辑抄一遍就好了。还记得我们说 use-package 中 :init 标签表示加载插件前执行的逻辑（如，启动 ivy-mode），:config 表示加载后执行的逻辑（如，设置一些变量，这显然是加载插件后的逻辑，因此写在 :config 后面）。至于绑定快捷键，只需要照抄一下。最后一行的配置涉及到了 keymap，keymap 就是指在某一模式下的键盘输入事件的集合。例如我们平时输 C-x 后 Emacs 并不会进行任何操作，而是等待你输入下一个快捷键，原因就在于 C-x 是当前 keymap 的一个快捷键前缀，尚未形成一个命令，所以要继续等待。最后一行的配置表示在 minibuffer-local-map 这个 keymap 内重新定义 C-r。在 use-package 这个也是可以同样配置的。\n特别的，注意到官网 Counsel 中提示了可以直接通过执行 counsel-mode 来绑定快捷键，所以我们当然也可以利用起来，最后的代码只需要这样：\n1(use-package counsel 2 :ensure t) 3 4(use-package ivy 5 :ensure t 6 :init 7 (ivy-mode 1) 8 (counsel-mode 1) 9 :config 10 (setq ivy-use-virtual-buffers t) 11 (setq search-default-mode #\u0026#39;char-fold-to-regexp) 12 (setq ivy-count-format \u0026#34;(%d/%d) \u0026#34;) 13 :bind 14 ((\u0026#34;C-s\u0026#34; . \u0026#39;swiper) 15 (\u0026#34;C-x b\u0026#34; . \u0026#39;ivy-switch-buffer) 16 (\u0026#34;C-c v\u0026#34; . \u0026#39;ivy-push-view) 17 (\u0026#34;C-c s\u0026#34; . \u0026#39;ivy-switch-view) 18 (\u0026#34;C-c V\u0026#34; . \u0026#39;ivy-pop-view) 19 (\u0026#34;C-x C-@\u0026#34; . \u0026#39;counsel-mark-ring); 在某些终端上 C-x C-SPC 会被映射为 C-x C-@，比如在 macOS 上，所以要手动设置 20 (\u0026#34;C-x C-SPC\u0026#34; . \u0026#39;counsel-mark-ring) 21 :map minibuffer-local-map 22 (\u0026#34;C-r\u0026#34; . counsel-minibuffer-history))) 将以上代码写在 init.el 中，就可以加载 ivy 包（如未安装就下载安装），在加载前（:init 标签）启动 ivy-mode、counsel-mode，加载后（:config 标签）设置三个变量的值、绑定一些额外的快捷键（:bind 标签）并针对 keymap 设定（ :bind 标签内的 :map 标签）。\n直接使用 use-package 来安装 ivy、counsel 和 swiper 可能存在一些依赖问题，笔者暂未解决。对此可以手动安装，例如 M-x package-install counsel。 效果 例如，按下 C-x C-f 时，我们不再调用的是 find-file ，而是 counsel-find-file，最主要的区别便是会把当前目录下所有文件列表显示在一个新的 Minibuffer 中，当你想到上一级目录时，也只需要按下一次 \u0026lt;backspace\u0026gt; ，而不用像之前一样要删除一个词。 此外，还可以模糊输入文件名就可以找到相应的文件，若按下 C-r 则可以显示之前调用 counsel-find-file 打开过的历史记录。\n同样的，M-x 也被替换为了 counsel-M-x，会将命令也列表显示出来，同样也可以模糊输入命令。\nC-x b切换 Buffer 、C-s 搜索、M-y 使用剪贴板历史等等，都会提供类似的补全功能，读者可以自行多尝试尝试！\n在执行 counsel-find-file 过程中，当输入了一个文件名前缀时，ivy 会自动为你补全最接近的文件名，这在想要创建文件时反而引入了麻烦。例如上图中我们已经有了 names.txt 文件，此时如果想要创建一个名为 names 的文件的话，输入 names 后按下回车，ivy 会认为你在找 names.txt 而直接打开它。 对于这种情况，需要按下 C-M-j （ivy-immediate-done 命令），就会直接创建名为 names 的文件而不触发补全。 同类插件 和 ivy 功能基本类似的插件有 helm 和 ido ， 读者可以自己选择自己更为喜爱的。\namx 主页\n这个插件可以记录我们每次调用 M-x 时输入的命令历史，然后每次将最常用的显示在前面，这对于我们短时间希望频繁输入某几个命令的场景非常有用。amx 的配置十分简单：\n1(use-package amx 2 :ensure t 3 :init (amx-mode)) ace-window 主页\n这又是一个 abo-abo（Oleh Krehel）的项目。我们用 Emacs 多窗口时，window 超过 3 个后就很难使用 C-x o 进行切换了。ace-window 对 C-x o 重新绑定，使用时可以为每个 window 编个号，用编号进行跳转。\n配置：\n1(use-package ace-window 2 :ensure t 3 :bind ((\u0026#34;C-x o\u0026#34; . \u0026#39;ace-window))) mwim 主页\n还记得我们提到 C-a 对应了 move-beginning-of-line，M-m 对应了 back-to-indentation。当代码有缩进时，前者会把光标移动到行首（到空格之前），后者会移动到代码文字的开头（到空格之后）。那么实际中这两个按法差别较大，且不易区分，使用起来不方便。mwim 就将二者合并，覆盖 C-a 为 mwim-beginning-of-code-or-line，这样按一次 C-a 时移动到代码文字开头，再按一次则是移动到整行的行首，如此反复。\n同时，更有意义的是，它还可以覆盖 C-e move-end-of-line 为 mwim-end-of-code-or-line，当本行代码结尾有注释时，第一次按 C-e 将光标移动到代码尾部、注释之前。再按一次则是移动到整行的行尾。 这就大大提高了写代码的效率。\n1(use-package mwim 2 :ensure t 3 :bind 4 (\u0026#34;C-a\u0026#34; . mwim-beginning-of-code-or-line) 5 (\u0026#34;C-e\u0026#34; . mwim-end-of-code-or-line)) undo-tree 主页\n还记得 Emacs 令人头疼的撤销和重做操作吗？C-x u 对应了 undo 命令，而 redo 则需要先 C-g 让历史记录环方向转换，再进行 undo 表示 redo。 事实上这一设定的原理也很直白，有一个表情包吐槽了这一设定：\n翻译一下就是：想要撤销之前的撤销？你如果撤销，然后再做一个没有任何内容编辑的行动，之后下一个撤销就会撤销刚刚的撤销，于是形成了一个重做。C-g 就是起到其中“没有任何内容编辑的行动”的作用。\n事实上这也的确让很多人头疼。于是自有人写了插件来弥补。只需一张图，你即可了解 undo-tree 的用法：\n所有的编辑都会成为 undo-tree 上的一个节点。当按下 C-x u 时就会显示出这棵树。当你撤销时，只需要向上寻找历史节点。而当你又做了其它编辑，这棵树就会分叉。也就意味着，你之前的记录依然被保留，你随时可以反悔，也不用担心不小心编辑了内容导致无法重做。\nundo-tree 被放在了 GNU ELPA 上，并不是 MELPA，所以读者如果用了国内镜像，一定要把 GNU ELPA 加入到包管理链接中，详见上一篇教程的 MELPA 章节。\n配置方面，简单的使用只需要如下配置。然而其默认会为每个文件生成一个隐藏文件用来保存之前的历史记录，这对项目是个污染。因此，最后的 :custom 中设置了变量 undo-tree-auto-save-history 为空，就是关闭了这个保存功能。此外，也可以将所有的 undo-tree 历史记录保存到一个专门的文件夹，需要通过变量 undo-tree-history-directory-alist 来设置，读者详见文档。\n1(use-package undo-tree 2 :ensure t 3 :init (global-undo-tree-mode) 4 :custom 5 (undo-tree-auto-save-history nil)) smart-mode-line（可选） 主页\n一个让 mode line 更加漂亮、方便管理的插件，可以自动做一些模式的隐藏等等，也可以选择多种主题。具体读者可以自行探索。这里给个基础配置，在教程的外观与主题中会额外介绍一部分配置：\n1(use-package smart-mode-line 2 :ensure t 3 :init (sml/setup)) good-scroll （可选） 主页\n在现代图形界面操作系统中，光标在上下移动、翻页的时候 Emacs 会直接刷新界面，滚动时也是按行滚动，比较粗糙。good-scroll 提供了平滑滚动，并且支持变速滚动，更加顺手。\n1(use-package good-scroll 2 :ensure t 3 :if window-system ; 在图形化界面时才使用这个插件 4 :init (good-scroll-mode)) 经过了以上介绍，相信读者应该能够感受到 Emacs 的不少痛点被解决了，现在开始 Emacs 应当是一个可以顺畅使用的现代编辑器了。下一篇笔者将介绍一些功能增强类插件，开始真正释放 Emacs 的强大。\n","link":"https://pavinberg.github.io/emacs-book/zh/optimization/","section":"","title":"插件：功能优化类"},{"body":"上一篇教程我们解决了 Emacs 的主要痛点，这一篇我们将开始介绍 Emacs 更为强大的功能。 有几个插件的篇幅较长，原因在于其配置和使用相对复杂和特别，但绝对是效率利器，需要读者静下心学习。\nBook marks Book marks - EmacsWiki\n这是 Emacs 自带的功能。根据名字即可大概猜到其功能，就和电子书中的书签功能一样，在当前光标位置打上一个书签，之后可以随时跳转回来。主要涉及到如下四个命令：\nC-x r m （bookmark-set） ：设置书签。可以为书签起个标记名称，默认为文件名。也可以为目录打书签。\nC-x r b（bookmark-jump，如果在上一篇教程中安装了 counsel，应当已被覆盖为 counsel-bookmark）：跳转到书签。\nC-x r l （bookmark-bmenu-list）：列出已有书签。\nM-x bookmark-delete ：删除书签。\n这在阅读代码的时候可是个十分方便的功能。\nivy view 顺着 Book marks，我们顺带一提上一篇教程中提及的 ivy 插件的额外功能——ivy view。它与 Book mark 的区别是直接将当前 Frame 中的 Window 的状态都进行保存，然后状态间切换。例如我们打开了多个窗口做一件事，但是中途需要看一些其它文件，那么想要回到刚刚的窗口摆放方式就是 ivy view 出场的地方了。与 Book marks 类似，涉及三个命令：\nivy-push-view：保存当前的窗口状态。在上一篇教程的配置中绑定为快捷键 C-c v。\nivy-switch-view：切换窗口状态。 在上一篇教程的配置中绑定为快捷键 C-c s。\nivy-pop-view ：删除保存了的窗口状态。在上一篇教程的配置中绑定为快捷键 C-c V。\nwhich-key（可选） 主页\n这是一个实用小工具，专门针对 Emacs 快捷键多而杂的问题，安装后，当按下部分快捷键前缀时，它会通过 minibuffer 提示你都有哪些可以按的快捷键及其命令名。例如启动了 hs-minor-mode 后，我们正常可以通过 C-c @ C-h 折叠代码块、用 C-c @ C-s 来展开代码块。但这个快捷键很长，时常记不住，那么有了 which-key 后我们可以先按下 C-c @ ，此时 which-key 就会提示我们接下来可以按的键：\n对于选项过多的前缀，例如 C-x ，which-key 会显示出非常多的选项，那么就需要翻页，根据它的提示，我们只需要按下 C-h，然后按 n 或 p 进行向下翻页和向上翻页。\n只需如下配置文件：\n1(use-package which-key 2 :ensure t 3 :init (which-key-mode)) 因为事实上快捷键熟练后并没有那么需要这个插件，有时候按下例如 C-x 这样的前缀后又会产生大量的备选项，所以并不是完全解决了这一痛点。但它配置简单，没有学习和配置成本，所以依然建议大家使用。而想要更好解决快捷键繁杂的问题，可以进一步参考下面提到的插件 hydra。\navy 主页\navy - 相关博客\navy 又是一个 abo-abo（Oleh Krehel）开发的 强大 插件，笔者 极力推荐读者使用，熟练后效率可以成倍提升。其最最基本的功能就是无需鼠标的快速光标跳转（思想来自于 vim 的 easymotion），但其能力远不止于此，它可以让你在不操作光标的情况下，快速对文本进行复制、剪切、粘贴，大大提高了围绕光标的操作的效率。接下来将会花一些篇幅介绍。第三个链接是一个博客，有详细地介绍 avy 的更多用法，读者如果感兴趣可以阅读一下，以下是 avy 主要内容的介绍。\n操作逻辑抽象 在博客中提到了 avy 操作逻辑的抽象概念，也是很多 Emacs 命令的操作抽象：Filter、Select、Act，翻译过来就是“ 筛选”、“ 选择 ”、“ 行动 ”。举个例子，我们按 C-x C-f 打开文件，此时列出了当前目录下的所有文件名，按下文件名的前缀，待选文件的范围就会缩小，这就叫“ 筛选 ”；我们在其中最终选择了一个文件，这叫“选择 ”；最后按下回车，此时 Emacs 就会打开并切换到那个文件，这就叫” 行动 “。很多操作都可以归为这种模式。\n基本用法 那么你的第一反应可能是，这不就是很正常的一个命令的用法吗，为什么说的这么抽象？ avy 就是在这个模式上做出了文章，其核心思想就是将三者进行解耦合，让这个模式支持更多的应用场景。我们来看看具体的用法。首先请在 ~/.emacs.d/init.el 中加入如下配置：\n1(use-package avy 2 :ensure t 3 :bind 4 ((\u0026#34;C-j C-SPC\u0026#34; . avy-goto-char-timer))) 注意： 这里设置快捷键的前提是在前面有执行过 (global-set-key (kbd \u0026quot;C-j\u0026quot;) nil) ，将本身的 C-j 快捷键的功能去掉。在大部分模式下 C-j 的功能是 electric-newline-and-maybe-indent，是一个换行的快捷键，笔者个人觉得使用频率很低，于是索性去掉了这些快捷键。然后将 C-j 和其它键组合绑定了少量快捷键。当然，读者也可以选择使用 avy 中示例的 M-j 作为快捷键。 加入后让光标在这个作用域内，按下 C-M-x 让配置生效 。此时，就可以使用 avy 了 。假如我们有如下的 Python 代码：\n1 def hello_world(): 2 print(\u0026#34;Hello, world!\u0026#34;) 3 4 def hello_coder(): 5 print(\u0026#34;Hello, coder!\u0026#34;) 6 7 def hello_emacser(): 8 print(\u0026#34;Hello, emacser!\u0026#34;) 9 10 ... 那么如果此时我们的光标在其它位置，例如一个下面的代码中，而希望将光标移动到 hello_emacser 函数的位置，我们要么需要使用鼠标，要么需要用向上键一行一行地缓慢挪动，似乎都不够完美。有了 avy，我们就可以按下我们刚刚设定好的快捷键 C-j C-SPC 调用 avy-goto-char-timer，此时 avy 在等待你输入“目标位置的部分文本”，例如这个场景下，就输入：“h“、“he” 、”hel“ 等等都可以（要快一点输入），此时，原本是 \u0026quot;h\u0026quot; 的位置会被替换为一个高亮了的其它字母，那么我们希望跳转到 hello_emacser 的函数定义处，对应了字母 g，于是我们紧接着按 g，就会发现光标成功移动到了 hello_emacser 的开头。\n按照刚刚提到的模式，可以这样理解这个场景：光标位置正常可以是整个 Window 上的任意位置，但当使用 avy 并输入了部分文本后，就将目标光标位置的范围缩小到了上图的 6 个位置，这就是“ 筛选 ”。我们按下 g 时就是” 选择 “，最后 avy 自动执行“ 行动 ” ——将光标挪到相应位置。\n进阶用法 别忘了，跳转只是它最最基本的功能。事实上，当我们“ 筛选 ”后、” 选择 “前，可以更改 avy 的“ 行动”，有哪些行动呢？读者可以在输入了“部分文本”后，按下 ? 键，就会显示出 avy 当前支持的“ 行动 ”。\n例如下图所示，我们写着写着希望换一种写法，对代码进行重构，把上面的三个 print 语句合并在一个函数中，那么一行行分别去选中、复制、回来、粘贴肯定是很麻烦的。于是，我们按下 C-j C-SPC，输入 p ( print 的开头字母），此时按下 ?，下面的 Minibuffer 就会显示出可以选择的其它行动，我们希望使用 Y: yank-line，于是输入 Y（注意大小写），然后按下我们目标 print 语句的标签，例如 a，这时，a 对应的语句就完全被复制到了当前光标所在的位置。我们的光标没有丝毫的移动，就成功将一行代码复制了过来。\n读者可以自行试试其它命令的效果，例如 kill-stay 可以“隔空剪切文本”、teleport 可以“把远处的文本传送到当前位置“等等。注意我们中途按下的 ? 只是对大家的提示 ，如果熟练记住了几个常用的“行动”，就可以直接省略按 ? 了 。\n另外，记得尝试一下命令 avy-copy-line、avy-move-line、avy-copy-region 和 avy-move-region， 可以以行为单位进行操作，光标都不用动，就可以快速复制、剪切一行乃至一段文字，效率非常高。\n读者会发现自己的 avy 中并没有笔者的 e: embark 这一项。事实上，这些可以选择的命令也是我们可以自定义的，这里的embark 就是添加了使用 embark 插件的一个“ 行动 ”，在下文会进一步介绍。如果读者不喜欢这种输多个字符然后等待 avy 生效这样的方式，也可以把快捷键调用的命令改为例如 avy-goto-word-1，这时就可以通过输某个词的首字母就可以直接触发 avy 的筛选。 marginalia 主页\n一个为 Emacs minibuffer 中的选项添加注解的插件。\n1(use-package marginalia 2 :ensure t 3 :init (marginalia-mode) 4 :bind (:map minibuffer-local-map 5 (\u0026#34;M-A\u0026#34; . marginalia-cycle))) embark（可选） 主页\nembark - 相关博客\nembark 是另一个比较神奇的工具。Emacs 基本的操作流程是先输入命令再输入命令作用的对象。例如，我们先按下 C-x C-f 再输入文件名来打开文件。但是有的时候，我们按下命令、选择了文件后，可能又后悔了，想要对相同的文件输入另一个命令。例如我们按下 C-x k 打算关闭一个后台 buffer，然后输入了文件名，这时我们忽然想再查看一眼那个文件。那么平常，我们只好按下 C-g 放弃这次命令，再用 C-x b 切换过去。而有了 embark ，我们可以在按下 C-x k 、输入了部分文件名选中文件后 ，按下 C-. 触发 embark- act，这时按下 o 就可以在另一个新的窗口打开这个 buffer 了。我们无需放弃命令重新输入，而是继续输入就好了。\n由于 ivy 和 avy 的使用其实已经大大加强了 Emacs 对文本和 Buffer 的操作能力，相对而言 embark 并没有那么必须，所以这里笔者标记为了可选。 直接使用官网提供的配置就好（官网中强烈建议 embark 和 marginalia 一同使用，所以最好先装好 marginalia）：\n1(use-package embark 2 :ensure t 3 :init 4 ;; Optionally replace the key help with a completing-read interface 5 (setq prefix-help-command #\u0026#39;embark-prefix-help-command) 6 :config 7 ;; Hide the mode line of the Embark live/completions buffers 8 (add-to-list \u0026#39;display-buffer-alist 9 \u0026#39;(\u0026#34;\\\\`\\\\*Embark Collect \\\\(Live\\\\|Completions\\\\)\\\\*\u0026#34; 10 nil 11 (window-parameters (mode-line-format . none)))) 12 :bind 13 ((\u0026#34;C-.\u0026#34; . embark-act) ;; pick some comfortable binding 14 (\u0026#34;C-;\u0026#34; . embark-dwim) ;; good alternative: M-. 15 (\u0026#34;C-h B\u0026#34; . embark-bindings))) ;; alternative for `describe-bindings\u0026#39; 如果想要让 avy 也支持 embark，需要在 avy 的配置中添加 :config：\n1(use-package avy 2 :ensure t 3 :config 4 (defun avy-action-embark (pt) 5\t(unwind-protect 6\t(save-excursion 7 (goto-char pt) 8 (embark-act)) 9 (select-window 10 (cdr (ring-ref avy-ring 0)))) 11\tt) 12 (setf (alist-get ?e avy-dispatch-alist) \u0026#39;avy-action-embark) 13 :bind 14 ((\u0026#34;C-j C-SPC\u0026#34; . avy-goto-char-timer))) hydra 主页\nhydra 进一步解决了 Emacs 的复杂的命令如何组织的问题，这又是一个 abo-abo（Oleh Krehel）编写的插件。which-key 虽然对快捷键起到了提示作用，但是对于 Emacs 数量这么庞大的命令来说还是有很多不足。\nhydra 主要功能是把一组特定场景的命令组织到一起， 通过简单按键来进行调用。这个思路和 Vim 的各种 mode 是类似的。例如上一篇教程中提到的 undo-tree、上文的 avy 和接下来提到的插件 multiple-cursors 、调试插件 dap-mode，我们会发现它们有功能相近的多个命令，实际中都要频繁使用，而都绑定上快捷键又会难以记忆。那么有了 hydra 我们就可以把它们都组织到一起。我们先以 undo-tree 举个小例子。\n首先安装好 hydra ，而由于我们希望在 use-package 里进行配置，再安装一个 use-package-hydra 小插件可以让我们的 use-package 多一个 :hydra 关键字，可以更方便地配置。 这段配置应当写在靠前一点的位置比较保险。\n1(use-package hydra 2 :ensure t) 3 4(use-package use-package-hydra 5 :ensure t 6 :after hydra) 然后，我们起初对 undo-tree 的配置非常简单：\n1(use-package undo-tree 2 :ensure t 3 :init (global-undo-tree-mode)) 而想要和 hydra 结合可以变为：\n1(use-package undo-tree 2 :ensure t 3 :init (global-undo-tree-mode) 4 :after hydra 5 :bind (\u0026#34;C-x C-h u\u0026#34; . hydra-undo-tree/body) 6 :hydra (hydra-undo-tree (:hint nil) 7 \u0026#34; 8 _p_: undo _n_: redo _s_: save _l_: load \u0026#34; 9 (\u0026#34;p\u0026#34; undo-tree-undo) 10 (\u0026#34;n\u0026#34; undo-tree-redo) 11 (\u0026#34;s\u0026#34; undo-tree-save-history) 12 (\u0026#34;l\u0026#34; undo-tree-load-history) 13 (\u0026#34;u\u0026#34; undo-tree-visualize \u0026#34;visualize\u0026#34; :color blue) 14 (\u0026#34;q\u0026#34; nil \u0026#34;quit\u0026#34; :color blue))) 看起来很长，其实就是定义了一个小表格，可以让我们先按下 C-x C-h u 来调用 hydra-undo-tree/body 这个命令，它会在 minibuffer 中显示出我们配置中的字符串，形成下图效果：\n此时，我们就可以通过选择 p、n、s、l 和 u 来分别触发五个 undo-tree 的命令了。 所以可以总结为，hydra 可以任意将一些命令组织在一起，方便在某个场合下调用。\n具体来说，我们通过 :hydra 标签可以声明这样一组命令，起了个名字，在上面的例子中就是 hydra-undo-tree，被称为 hydra-awesome，习惯以 hydra- 开头。想要调出这一组，需要输入的是就是加上 /body，上例中也就是 hydra-undo-tree/body，当然你可以选择直接调其中的某个命令例如 hydra-undo-tree/undo-tree-undo。\n一个值得注意的小细节是每个提示词的颜色，有的为红色，有的为蓝色。事实上颜色是有相对应的设置的，红色的表示按过了之后依然可以继续按，不会退出 hydra；蓝色表示按了一次就会退出 hydra。例如上例中，我们可能需要多次 undo 和 redo，所以 p 和 n 都是红色的。而 u可以展示出 undo-tree，而展示出来之后我们就不再需要 hydra 了，所以我们把 u配置成了蓝色。所有颜色如下：\n| color | toggle | |----------+----------------------------| | red | | | blue | :exit t | | amaranth | :foreign-keys warn | | teal | :foreign-keys warn :exit t | | pink | :foreign-keys run | 不想用颜色的话也可以直接用 :exit t 表示按完后就退出。此外还有很多细节可以调整，例如超时退出，具体参考 hydra 的主页 Wiki吧。\nmultiple-cursors 主页\n多光标编辑可是编辑器的必备需求。这个插件提供了多种生成多光标的方式。\n连续多行 ：我们按下 C-SPC 触发一次 set-mark，随后让光标向下移动，再输入 M-x mc/edit-lines 就生成连续多行光标。 编辑多处同一段文本 ：选中文本，输入命令mc/mark-next-like-this、mc/mark-previous-like-this、 mc/mark-all-like-this，看名字就知道，分别可以标记下一个词、上一个词、所有词。还可以用 mc/skip-to-next-like-this 和 mc/skip-to-previous-like-this 跳过一部分。 鼠标点击选择 ：见配置，将 mc/toggle-cursor-on-click 绑定到某个键位。笔者使用的是 Ctrl+ Shift + 鼠标左键。 1(use-package multiple-cursors 2 :bind 3 (\u0026#34;C-S-\u0026lt;mouse-1\u0026gt;\u0026#34; . mc/toggle-cursor-on-click)) 可以看到这个插件的命令比较杂，一一绑定快捷键难以记忆。这就是又一次要使用 hydra 形成一组快捷键了：\n1(use-package multiple-cursors 2 :ensure t 3 :after hydra 4 :bind 5 ((\u0026#34;C-x C-h m\u0026#34; . hydra-multiple-cursors/body) 6 (\u0026#34;C-S-\u0026lt;mouse-1\u0026gt;\u0026#34; . mc/toggle-cursor-on-click)) 7 :hydra 8 (hydra-multiple-cursors 9 (:hint nil) 10 \u0026#34; 11Up^^ Down^^ Miscellaneous % 2(mc/num-cursors) cursor%s(if (\u0026gt; (mc/num-cursors) 1) \\\u0026#34;s\\\u0026#34; \\\u0026#34;\\\u0026#34;) 12------------------------------------------------------------------ 13 [_p_] Prev [_n_] Next [_l_] Edit lines [_0_] Insert numbers 14 [_P_] Skip [_N_] Skip [_a_] Mark all [_A_] Insert letters 15 [_M-p_] Unmark [_M-n_] Unmark [_s_] Search [_q_] Quit 16 [_|_] Align with input CHAR [Click] Cursor at point\u0026#34; 17 (\u0026#34;l\u0026#34; mc/edit-lines :exit t) 18 (\u0026#34;a\u0026#34; mc/mark-all-like-this :exit t) 19 (\u0026#34;n\u0026#34; mc/mark-next-like-this) 20 (\u0026#34;N\u0026#34; mc/skip-to-next-like-this) 21 (\u0026#34;M-n\u0026#34; mc/unmark-next-like-this) 22 (\u0026#34;p\u0026#34; mc/mark-previous-like-this) 23 (\u0026#34;P\u0026#34; mc/skip-to-previous-like-this) 24 (\u0026#34;M-p\u0026#34; mc/unmark-previous-like-this) 25 (\u0026#34;|\u0026#34; mc/vertical-align) 26 (\u0026#34;s\u0026#34; mc/mark-all-in-region-regexp :exit t) 27 (\u0026#34;0\u0026#34; mc/insert-numbers :exit t) 28 (\u0026#34;A\u0026#34; mc/insert-letters :exit t) 29 (\u0026#34;\u0026lt;mouse-1\u0026gt;\u0026#34; mc/add-cursor-on-click) 30 ;; Help with click recognition in this hydra 31 (\u0026#34;\u0026lt;down-mouse-1\u0026gt;\u0026#34; ignore) 32 (\u0026#34;\u0026lt;drag-mouse-1\u0026gt;\u0026#34; ignore) 33 (\u0026#34;q\u0026#34; nil))) 之后我们便可以使用 C-x C-h m 来列出所有的命令，然后选择即可。第一次用 multiple-cursors 可能会问你是否要将 xxx 命令应用到所有的光标上，读者根据具体情况判断即可，之后就不会反复提问了。\n这部分代码事实上来自于 hydra 的 Wiki，融入进了 use-package 中。读者也可以多去借鉴，也可自行调整。 dashboard 主页\n起初每当我们打开 Emacs 都有一个欢迎界面，显示了一些 Emacs 的帮助信息。这对刚入门而言比较方便，但当我们熟练后这个页面就逐渐无用了。dashboard 就是一个新的欢迎界面，可以列出最近打开的项目、最近打开的文件等等。按下 p 或 r 就可以快速跳转到相应小结里。还可以列出来标记过的书签、org-mode （Emacs 自带的一个强大的笔记系统）日程、自定义控件等。\n读者此时可能会发现自己的 Projects 节中没有内容，原因在于这部分是配合 projectile 插件使用的，我们将在下一教程中详细介绍 projectile。 1(use-package dashboard 2 :ensure t 3 :config 4 (setq dashboard-banner-logo-title \u0026#34;Welcome to Emacs!\u0026#34;) ;; 个性签名，随读者喜好设置 5 ;; (setq dashboard-projects-backend \u0026#39;projectile) ;; 读者可以暂时注释掉这一行，等安装了 projectile 后再使用 6 (setq dashboard-startup-banner \u0026#39;official) ;; 也可以自定义图片 7 (setq dashboard-items \u0026#39;((recents . 5) ;; 显示多少个最近文件 8\t(bookmarks . 5) ;; 显示多少个最近书签 9\t(projects . 10))) ;; 显示多少个最近项目 10 (dashboard-setup-startup-hook)) tiny 主页\nabo-abo 继续为我们带来好用的插件。tiny 可以实现一个方便的序号宏展开。举个小例子就一目了然了：我们想要定义一组函数分别名为 int fun01、int fun02、 …… 、int fun10，正常我们只能一个个手敲，但有了 tiny，我们可以输入一个这样的简单语法：\nm1\\n10|int func%02d () m 是个固定的前缀字符，\u0026quot;1\\n10\u0026quot; 表示 1 到 10 的数字，中间用回车换行分隔，竖线 | 后面是我们的格式化文本。然后我们调用 M-x tiny-expand 命令，就能得到如下文本：\nint func01 () int func02 () int func03 () int func04 () int func05 () int func06 () int func07 () int func08 () int func09 () int func10 () 插件主页有多个例子，读者可以去了解一下语法。它只需最简单的配置即可：\n1(use-package tiny 2 :ensure t 3 ;; 可选绑定快捷键，笔者个人感觉不绑定快捷键也无妨 4 :bind 5 (\u0026#34;C-;\u0026#34; . tiny-expand)) highlight-symbol 主页\n这个插件可以高亮出当前 Buffer 中所有的、与光标所在处的符号相同的符号。也就是例如一些同名变量、函数名等。虽然在后面我们使用一些其他插件时也会捎带有类似功能，但它可以同时高亮很多字符，便于阅读代码等。\n1(use-package highlight-symbol 2 :ensure t 3 :init (highlight-symbol-mode) 4 :bind (\u0026#34;\u0026lt;f3\u0026gt;\u0026#34; . highlight-symbol)) ;; 按下 F3 键就可高亮当前符号 rainbow-delimiters 主页\n这个插件可以用不同颜色标记多级括号，方便看清代码块（尤其在 EmacsLisp 中）。\n1(use-package rainbow-delimiters 2 :ensure t 3 :hook (prog-mode . rainbow-delimiters-mode)) evil（为 Vim 用户） 主页\nevil 可以让习惯了 Vim 的用户在 Emacs 中使用 Vim 按键方式，大大减轻了 Vim 用户转入 Emacs 的成本。笔者本人不是个 Vim 用户，所以对此没有深入研究。基本配置只需参照官网即可，其中提到了少量依赖，读者可以自行检查。两个主要 ”Emacs 发行版“ [Doom Emacs](https://github.com/hlissner/doom- emacs) 和 Spacemacs 都是默认支持的，所以这二者对 Vim 转 Emacs 且不喜欢花太多时间配置的人来说非常合适。\n1(use-package evil 2 :ensure t 3 :init (evil-mode)) evil 可以使用 C-z 切换 Emacs 按键模式和 Vim 按键模式。当然在终端中，这会覆盖掉挂起功能，想要挂起可以按 C-x C-z。 ","link":"https://pavinberg.github.io/emacs-book/zh/enhancement/","section":"","title":"插件：功能增强类"},{"body":"经过了两轮的插件安装，我们已经具备了一个基础功能完备的编辑器了，但是说到底，代码编辑器最重要的目的便是用来编程了。本篇将开始对编程相关的插件进行介绍，但是我们知道编程领域十分广阔，本教程不可能涉及全部，所以本篇会介绍其中最关键的核心逻辑，只要领略了它，读者就可以自由变换、拓展到其它领域中去。\n编辑器最基本需要三大方面的功能：\n对编程进行辅助：自动补全、语法检查、代码跳转等。 项目管理、编译、运行、调试、版本控制等。 与相关开发工具结合等。 其中第三点不同的领域有不同的方案，每个人也有每个人的偏好，难以概括，本文不会进行深入的介绍，但相信读者经过了本教程的学习，完全有能力根据自己的需求进行探索。\n自动补全 基本配置 Emacs 最广为使用的补全插件便是 company-mode，其官方主页上已有详细的说明。可进行如下配置：\n1(use-package company 2 :ensure t 3 :init (global-company-mode) 4 :config 5 (setq company-minimum-prefix-length 1) ; 只需敲 1 个字母就开始进行自动补全 6 (setq company-tooltip-align-annotations t) 7 (setq company-idle-delay 0.0) 8 (setq company-show-numbers t) ;; 给选项编号 (按快捷键 M-1、M-2 等等来进行选择). 9 (setq company-selection-wrap-around t) 10 (setq company-transformers \u0026#39;(company-sort-by-occurrence))) ; 根据选择的频率进行排序，读者如果不喜欢可以去掉 安装后，输入前缀即可弹出自动补全。用 M-p 和 M-n 上下选择， Meta 键 + 一个数字选择相应标号的备选项。\n此外，如果读者使用图形界面，可以再安装一个 company-box 用以显示图标：\n1 (use-package company-box 2 :ensure t 3 :if window-system 4 :hook (company-mode . company-box-mode)) TabNine - AI 自动补全 Emacs 中自然也可以使用更加时髦的 AI 自动补全工具，例如 TabNine。TabNine 是一个比较通用的自动补全工具，可以为许多编辑器提供支持，Emacs 当然不会掉队。根据 TabNine for Emacs 中的指导，我们配置一下即可：\n1(use-package company-tabnine 2 :ensure t 3 :init (add-to-list \u0026#39;company-backends #\u0026#39;company-tabnine)) 随后，重启 Emacs，输入命令：M-x company-tabnine-install-binary，来安装 TabNine 的后台程序。之后就可以正常使用了。但是总的来说，AI 插件会导致偶尔的高 CPU 占用，如果电脑硬件性能不佳，建议尽量关闭后台训练功能，或者是直接使用传统补全插件就好。\nTip 1：想要打开 TabNine 的设置页面只需要在任意位置输入：tabnine::config，随后会弹出一个浏览器窗口显示 TabNine 的相关设置。 Tip 2：TabNine 学生认证可以免费获得 TabNine Pro 的使用资格，包括更多的备选项等。 代码片段模板 IDE 通常有代码片段模板，可以快速展开常用代码，例如 C/C++ 语言中输入了 “for” 之后按下 \u0026lt;TAB\u0026gt;，会展开出形如 for (init-statement; condition; inc-expression) 这样的结果。在 Emacs 中我们可以使用插件 yasnippet 来完成这一任务。\n1(use-package yasnippet 2 :ensure t 3 :hook 4 (prog-mode . yas-minor-mode) 5 :config 6 (yas-reload-all) 7 ;; add company-yasnippet to company-backends 8 (defun company-mode/backend-with-yas (backend) 9 (if (and (listp backend) (member \u0026#39;company-yasnippet backend)) 10\tbackend 11 (append (if (consp backend) backend (list backend)) 12 \u0026#39;(:with company-yasnippet)))) 13 (setq company-backends (mapcar #\u0026#39;company-mode/backend-with-yas company-backends)) 14 ;; unbind \u0026lt;TAB\u0026gt; completion 15 (define-key yas-minor-mode-map [(tab)] nil) 16 (define-key yas-minor-mode-map (kbd \u0026#34;TAB\u0026#34;) nil) 17 (define-key yas-minor-mode-map (kbd \u0026#34;\u0026lt;tab\u0026gt;\u0026#34;) nil) 18 :bind 19 (:map yas-minor-mode-map (\u0026#34;S-\u0026lt;tab\u0026gt;\u0026#34; . yas-expand))) 20 21(use-package yasnippet-snippets 22 :ensure t 23 :after yasnippet) 这里笔者的配置略微复杂，主要有两个考虑：\n默认情况，yasnippet 当光标位于一个可展开的字符串后面时，按下 \u0026lt;tab\u0026gt; 键会自动展开。然而，\u0026lt;tab\u0026gt; 键在 Emacs 中本身就有着一个对齐缩进的作用，当我们写代码时，光标不论在一行代码的哪里，只要我们按下 \u0026lt;tab\u0026gt;，就会将这行代码缩进到最合理的位置。于是这会造成一个误判，例如我们有个 for 循环，我们希望用 \u0026lt;tab\u0026gt; 自动缩进这行代码，而光标恰好处于 for 的后面，这时会触发 yasnippet 再次将 for 展开。笔者采取的方案是由用户显式调用 yasnippet 的展开，于是解绑了 \u0026lt;tab\u0026gt; 键，换成了 S-\u0026lt;tab\u0026gt;（也就是 Shift+\u0026lt;tab\u0026gt;）。 我们希望 yasnippet 可以与自动补全协同，让自动补全也为我们补全 yasnippet 代码片段。默认情况，我们需要显式调用 company-yasnippet 来查看专属 yasnippet 的自动补全。有些读者也许偏爱这一方式，那么就请去掉 :config 的前两句用来设置 company-backends 的代码。 第二个 use-package 所安装的 yasnippet-snippets 是一个模板集合，里面包含了常见的模板。读者也可以自定义模板，参考 yasnippet 的主页即可。\n最终效果图如下（还混用了下文提到的 lsp 插件）：\n文本展开 Emacs 还有一个非常实用的补全小功能 hippie。dabbbrev 与之功能相似，二者都是 Emacs 自带的功能。默认 M-/ 键就被绑定到了 dabbrev-expand 函数。笔者选择使用前者，替换掉了这个快捷键：\n1(global-set-key (kbd \u0026#34;M-/\u0026#34;) \u0026#39;hippie-expand) 当我们输入几个字符前缀，然后按下 M-/ 调用 hippie-expand 函数，它会根据前缀匹配后面的内容。不同于普通的代码补全，它的补全还包括了文件名、elisp 函数名等。它的补全规则不包含语法分析，而是纯文本补全，很适用于我们写一些重复性的相似代码/其它文本的场合。\n语法检查 语法检查有两个主流插件，一个是 flycheck，一个是 flymake，笔者个人感觉 flycheck 使用的人更多。\nflycheck 是一个对接 Emacs 和语法检查程序（也就是 linting）的插件。官网提供的方案是全局开启 flycheck：\n1(use-package flycheck 2 :ensure t 3 :init (global-flycheck-mode)) 笔者认为全局开启略有不妥。我们可以使用 hook 来指定什么情况下启动 flycheck，例如只在编程时使用：\n1(use-package flycheck 2 :ensure t 3 :config 4 (setq truncate-lines nil) ; 如果单行信息很长会自动换行 5 :hook 6 (prog-mode . flycheck-mode)) 那么，flycheck已就绪，特定语言的语法检查程序要如何安装呢？flycheck 的主页上已为你列好各种编程语言对应的语法检查程序列表，其中包含了相应的链接。\n例如，写 Python 的话，我们可以使用 python-flake8 或者 pylint。 例如使用 pylint 的话，在 Ubuntu 上可以用 apt 进行安装，在 macOS、Windows 上可以用 pip 来进行安装。\n编译型语言通常安装好编译器即可使用。例如 C/C++、Rust 安装好 gcc/clang、rustc 就可以了。\nflycheck 对 Windows 没有官方支持，但官网中提到也可以有方式使用。不过，在 Windows 上用 Emacs 做开发应该很少见吧 :-)。 代码分析 这一功能是指通过语法分析来进行诸如寻找函数和变量的定义、引用等等与编程语言本身相关的功能。传统方法中，每种语言都有一个专门为其设计的插件，例如 C/C++ 开发会用一些传统的 CEDET，gtag 等插件，Python 则用 elpy。但这类插件由于和编辑器直接耦合，完全由插件开发者控制，更新维护不一定及时，bug 也会较多。因此，笔者推荐使用微软为 VSCode 设计的 Language Server Protocol (LSP) 来完成这一任务。随着 LSP 发展壮大，它已成为一个开放的、统一的标准了，可以供 Emacs 使用。\nLSP 将代码分析解耦合为前端（即编辑器提供的功能，语言无关）和后端（语法分析，语言相关）两部分，二者通过一个规定好的协议来通信，也就是 LSP 协议，这样一来，编辑器开发者只需要做好前端部分，也就是 LSP client，后端的语言相关部分由语言开发者完成，称为 LSP server，分工明确，效率更高，体验也就会好很多。\n为 Emacs 提供 LSP 的插件有 lsp 和 eglot，相对来说使用 lsp 的人更多相对更稳定，本节将介绍 lsp 插件，及其相关的组合插件。lsp 应当与下文介绍的 projectile 一起使用。此外，这里的 lsp 只是前端部分， 后端需要单独安装，有的时候可以直接通过命令 lsp-install-server 让 lsp 为你自动安装，或者也可以手动安装你偏爱的 LSP server，下文“语言相关配置”中会介绍几个笔者常用语言的典型配置。\n首先根据其官网，我们就可以有一个最基础的配置：\n1(use-package lsp-mode 2 :ensure t 3 :init 4 ;; set prefix for lsp-command-keymap (few alternatives - \u0026#34;C-l\u0026#34;, \u0026#34;C-c l\u0026#34;) 5 (setq lsp-keymap-prefix \u0026#34;C-c l\u0026#34; 6\tlsp-file-watch-threshold 500) 7 :hook 8 (lsp-mode . lsp-enable-which-key-integration) ; which-key integration 9 :commands (lsp lsp-deferred) 10 :config 11 (setq lsp-completion-provider :none) ;; 阻止 lsp 重新设置 company-backend 而覆盖我们 yasnippet 的设置 12 (setq lsp-headerline-breadcrumb-enable t) 13 :bind 14 (\u0026#34;C-c l s\u0026#34; . lsp-ivy-workspace-symbol)) ;; 可快速搜索工作区内的符号（类名、函数名、变量名等） 这里区别于官网写了很多的 hooks，笔者选择将这些 hooks 和语言具体的配置放在一起，详见下文“语言相关配置”。当然读者也可以选择与官网保持一致，并没有本质区别，只是组织配置代码的逻辑不同。另外官网相应的 lsp 命令笔者使用的是 lsp-deferred 替代，主要区别是 lsp-deferred 会推迟 lsp 服务的启动直到文件完全被显示出来，使用这个的主要目的是为了避免在文件数量过多的大项目造成 LSP 服务端过载。\n(lsp-mode . lsp-enable-which-key-integration) 这句是让 lsp 与我们先前介绍过的 which-key 插件能够协作。最后一句让 lsp 为我们显示一下 breadcrumb，当我们完全配置好后，打开一个项目中的文件时，会在文件的最上面显示该文件的路径，这个被称为 breadcrumb。\n随后，我们如果希望有更现代的图形化的支持，例如光标停留在一个变量或者函数时，显示相关的定义缩略信息、文档注释等，那么我们可以再安装一个 lsp-ui 插件，并做如下配置：\n1(use-package lsp-ui 2 :ensure t 3 :config 4 (define-key lsp-ui-mode-map [remap xref-find-definitions] #\u0026#39;lsp-ui-peek-find-definitions) 5 (define-key lsp-ui-mode-map [remap xref-find-references] #\u0026#39;lsp-ui-peek-find-references) 6 (setq lsp-ui-doc-position \u0026#39;top)) 这几句的主要目的是替换本来的部分快捷键映射，由 lsp-ui 来进行接管，它同时为我们提供了一些跳转功能。这样我们可以使用 M-. 来寻找符号的定义，用 M-? 来寻找符号的引用。最后一句配置了 lsp-ui-doc （也就是刚刚提到的符号信息弹窗）在窗口上方显示，虽然很多现代编辑器都是显示在光标所在位置，但那会遮挡代码，有时十分惹人厌烦，所以一般会设置成显示在上方 top 或下方 bottom。如果确实希望显示在光标所在位置，可以改为 at-point。\n同时，lsp 还能和我们之前安装过的 ivy 进行协作，利用 ivy 辅助 lsp。\n1(use-package lsp-ivy 2 :ensure t 3 :after (lsp-mode)) 这样我们可以通过命令 lsp-ivy-workspace-symbol 来搜索当前工作区的符号。\n代码调试 与代码分析类似，微软设计 VSCode 时，对调试器也进行了前后端分离的设计，称为 Debug Adapter Protocol。Emacs 中可以使用 dap-mode 作为客户端。\ndap-mode 对各个语言的配置在其官方手册上有说明。下文对语言的介绍中会一一进行简单说明。\n1(use-package dap-mode 2 :ensure t 3 :after lsp-mode 4 :init (add-to-list \u0026#39;image-types \u0026#39;svg) 5 :commands dap-debug 6 :custom 7 (dap-auto-configure-mode t) 8 :hydra 9 (dap-hydra 10 (:color pink :hint nil :foreign-keys run) 11 \u0026#34; 12^Stepping^ ^Switch^ ^Breakpoints^ ^Debug^ ^Eval^ 13^^^^^^^^--------------------------------------------------------------------------------------------------------------- 14_n_: Next _ss_: Session _bb_: Toggle _dd_: Debug _ee_: Eval 15_i_: Step in _st_: Thread _bd_: Delete _dr_: Debug recent _er_: Eval region 16_o_: Step out _sf_: Stack frame _ba_: Add _dl_: Debug last _es_: Eval thing at point 17_c_: Continue _su_: Up stack frame _bc_: Set condition _de_: Edit debug template _ea_: Add expression. 18_r_: Restart frame _sd_: Down stack frame _bh_: Set hit count _ds_: Debug restart 19_Q_: Disconnect _sl_: List locals _bl_: Set log message 20 _sb_: List breakpoints 21 _se_: List expressions 22\u0026#34; 23 (\u0026#34;n\u0026#34; dap-next) 24 (\u0026#34;i\u0026#34; dap-step-in) 25 (\u0026#34;o\u0026#34; dap-step-out) 26 (\u0026#34;c\u0026#34; dap-continue) 27 (\u0026#34;r\u0026#34; dap-restart-frame) 28 (\u0026#34;ss\u0026#34; dap-switch-session) 29 (\u0026#34;st\u0026#34; dap-switch-thread) 30 (\u0026#34;sf\u0026#34; dap-switch-stack-frame) 31 (\u0026#34;su\u0026#34; dap-up-stack-frame) 32 (\u0026#34;sd\u0026#34; dap-down-stack-frame) 33 (\u0026#34;sl\u0026#34; dap-ui-locals) 34 (\u0026#34;sb\u0026#34; dap-ui-breakpoints) 35 (\u0026#34;se\u0026#34; dap-ui-expressions) 36 (\u0026#34;bb\u0026#34; dap-breakpoint-toggle) 37 (\u0026#34;ba\u0026#34; dap-breakpoint-add) 38 (\u0026#34;bd\u0026#34; dap-breakpoint-delete) 39 (\u0026#34;bc\u0026#34; dap-breakpoint-condition) 40 (\u0026#34;bh\u0026#34; dap-breakpoint-hit-condition) 41 (\u0026#34;bl\u0026#34; dap-breakpoint-log-message) 42 (\u0026#34;dd\u0026#34; dap-debug) 43 (\u0026#34;dr\u0026#34; dap-debug-recent) 44 (\u0026#34;ds\u0026#34; dap-debug-restart) 45 (\u0026#34;dl\u0026#34; dap-debug-last) 46 (\u0026#34;de\u0026#34; dap-debug-edit-template) 47 (\u0026#34;ee\u0026#34; dap-eval) 48 (\u0026#34;ea\u0026#34; dap-ui-expressions-add) 49 (\u0026#34;er\u0026#34; dap-eval-region) 50 (\u0026#34;es\u0026#34; dap-eval-thing-at-point) 51 (\u0026#34;q\u0026#34; nil \u0026#34;quit\u0026#34; :color blue) 52 (\u0026#34;Q\u0026#34; dap-disconnect \u0026#34;Disconnect\u0026#34; :color blue)) 53 :config 54 (dap-ui-mode 1) 55 (defun dap-hydra () 56\t(interactive) 57\t\u0026#34;Run `dap-hydra/body\u0026#39;.\u0026#34; 58\t(dap-hydra/body))) 其操作和我们平常使用 IDE 的操作是几乎一样的。我们可以通过 dap-breakpoint-add 命令或鼠标点击一行的左侧边缘来增加一个断点。当然也可以使用我们上面定义的 hydra，先调用 M-x dap-hydra 展开 hydra，然后输入相应命令。\n使用 dap-debug-edit-template 命令可以编辑调试所使用的模板，也就是调试命令的设置，如果没有自定义参数通常用默认的就好，无需进行此步操作。这就类似于 VSCode 的 launch.json 文件的作用。 把光标移入它生成的模板的括号内，按下 C-M-x 来让其生效，随后调用 dap-debug 开始调试。\n对于不同语言，需要安装好不同的后端程序，主要可以参考其官方手册。\n项目管理 事实上，上述的 lsp 插件还需要配合 projectile 插件使用。原因在于，目前为止，Emacs 只是在对文件进行操作，而没有项目的概念。我们实际的开发一定是以项目为单位的，lsp 的符号查找应当也是在项目范围的。projectile 就是为 Emacs 提供了项目管理的插件。\n1(use-package projectile 2 :ensure t 3 :bind ((\u0026#34;C-c p\u0026#34; . projectile-command-map)) 4 :config 5 (setq projectile-mode-line \u0026#34;Projectile\u0026#34;) 6 (setq projectile-track-known-projects-automatically nil)) 7 8(use-package counsel-projectile 9 :ensure t 10 :after (projectile) 11 :init (counsel-projectile-mode)) 当同时配好 projectile 和 lsp 后，我们如果打开一个项目内的文件，lsp 会提示你让你确认一下 projectile 推测出的项目的根目录，它会以此为范围做代码分析。\nprojectile 之所以能猜出来项目的根目录，逻辑是它从你打开的文件所在的目录一级一级向上寻找含有一些项目标志性的文件或目录，例如 .git、Makefile、CMakeLists.txt、 setup.py、Cargo.toml 等所在的目录认定为项目根目录。当然，也会有一些情况会推测错误，尤其对于大型项目包含子项目的情况会无法推测出根项目，所以它在询问你时，可以根据它的指示，手动指定项目的根目录。对于一些临时打开的文件，也可以直接跳过这个步骤。另外，也可以直接在项目的根目录下创建一个名为 .projectile 的空文件来明确提示 projectile 根目录在这里。 更多详细说明可以参考文档。 配置好上述的 counsel-projectile 后，我们还会拥有 counsel 和 projectile 的协作功能。例如，我们可以使用快捷键 C-c p p 调用 counsel-projectile-switch-project 来选择你曾经打开过的项目；再如，我们可以使用快捷键 C-c p f 来调用 counsel-projectile-find-file 快速打开一个项目内的文件。它利用 counsel 的搜索功能，可以模糊查找，也不必输入完整的路径，比正常 C-x C-f 要快速方便许多。\n局部变量 我们目前的配置都是全局的，Emacs 自然也可以对项目进行特别的配置。Emacs 有一个配置文件，就类似于 VSCode 的 .vscode/settings.json ，名为 .dir-locals.el。这个文件是一种特殊的语法，用于保存一些变量在这个项目下的取值。\n举个例子，如果我们的项目需要使用 clang 编译器的 c++11 标准做语法检查，应当如下操作：\n输入命令 M-x add-dir-local-variable 在操作结束后，会自动创建 .dir-locals.el 文件。首先它会让我们选择一下我们的这个变量是哪个 major mode 的变量，我们选择 c++-mode。随后，输入我们想要设置的变量 flycheck-clang-language-standard，输入回车确认。最后输入我们要设置的值 \u0026quot;c++11\u0026quot;（注意双引号表示字符串）。此时命令完成我们会跳转到 .dir-locals.el 文件的 buffer，内容如下：\n1;;; Directory Local Variables 2;;; For more information see (info \u0026#34;(emacs) Directory Variables\u0026#34;) 3 4((c++-mode . ((flycheck-clang-language-standard . \u0026#34;c++11\u0026#34;)))) 按下 C-x C-s 保存这个文件。下次打开这个项目的文件时，会提示你是否要应用这些变量的自定义值（为了安全性），按 y 即可生效。\n如果使用的是 gcc 编译器，将变量名中的 clang 替换成 gcc 就好。 环境变量 特别的，尤其是在 macOS 上，有时候我们可能会遇到一些在终端中的可执行文件放到 Emacs 图形界面下不能使用的问题。原因就在于图形界面的环境变量没有被正确设置。例如在图形界面使用 lsp 插件写 Python 程序并使用了 conda 虚拟环境，可能会提示你它找不到任何 language server，原因就在于 lsp 直接调用了 pyright 命令但是它没有在基本环境变量里。\n我们可以通过安装 Steve Purcell 写的插件 [exec-path-from-shell](https://github.com/purcell/exec-path- from-shell) 来完成：\n1(use-package exec-path-from-shell 2 :if (memq window-system \u0026#39;(mac ns)) 3 :ensure t 4 :init 5 (setq exec-path-from-shell-arguments nil) 6 (exec-path-from-shell-initialize)) 注意 ，完成这一任务会调用 Shell 进程，速度很慢，而如果遇到日常大家 export PATH=$PATH:path/to/bin 这种字符串拼接写法时会更慢，大大拖慢 Emacs 启动速度。根据 [Purcell 的建议](https://github.com/purcell/exec-path- from-shell#setting-up-your-shell-startup-files-correctly)，这里的配置就只针对 macOS 上使用了图形界面的情况才启动这个插件的功能，并且读者应当尽量做到：\n通过把 PATH 变量的设定放置在 ~/.profile、~/.bash_profile、~/.zshenv 而不是通通放入 ~/.bashrc 、~/.zshrc 。 不要使用 PATH 变量字符串拼接，而直接赋值。 版本管理 magit 是 Emacs 内部的 git 管理工具，提供了对 git 方便的调用和显示。magit 几乎无需配置。\n1(use-package magit 2 :ensure t) 安装好后，在一个 git 仓库中，我们可以使用 C-x g 调用 magit-status 查看状态，相当于 git status。\nmagit 的总体使用逻辑是一步一步进行输入的 。最基本的用法是使用 C-x M-g 调用 magit-dispatch，会列出来所有可以调用的子命令，选中后再输入一些可选的选项和接下来的命令，就和正常输入 git 的命令一样。\n使用 magit 做一些较为复杂的操作是非常方便的，举个例子，我们希望对比当前的这个源文件和上一个 commit 的区别，只需如下操作，其中每一步都有非常多的提示：\nC-x M-g 调用 magit-dispatch 。 d 选择 Diff 。 -- \u0026lt;tab\u0026gt; \u0026lt;enter\u0026gt; \u0026lt;enter\u0026gt; 自动填充当前文件名，表示我们只关注这个文件的异同。 r 选择 Diff range，因为我们想对比另一个 commit。 输入 HEAD^ （表示同一分支的上一个 commit）/ 想要对比的 commit ID。可以按 \u0026lt;tab\u0026gt; 进行提示。 由于 git 本身就是个非常复杂的工具，本文不做细致讨论，更多用法可以参考 magit 的主页。\n语言相关配置 笔者在 Emacs 上常使用的编译型语言是 C/C++ 和 Rust。Emacs 对 C/C++ 这种语言有一些基本的原生支持，对 Rust 这种后起之秀则有相应的插件可以管理。解释型语言里笔者主要使用 Python。Emacs 对于主流语言，包括但不限于 Java、Go、JavaScript、Ruby 等等都有完善的支持，论坛上经常可以见到相关讨论，读者如有需要可以自行探索。当然了，小众语言也都有支持的，但是资料相对较少，这倒也不是 Emacs 的问题了。\n这里没有提及代码排版工具，读者可以根据需要自己寻找合适的插件，例如 clang-format。\nC/C++ 编译 Emacs 本身就有一个 compile 函数可以用来编译 C/C++ 文件。打开一个 C/C++ 项目，使用默认配置调用 M-x compile，它会提示 make -k 来进行编译，也就是会默认我们是一个 make 项目。 如果我们没有 Makefile，例如我们在做算法题，只是想直接单独编译一个源文件，那么也可以直接手动输入命令：\n1$ g++ prog.cpp -g -o exec 事实上，这个默认值是一个 Emacs 字符串变量，如果我们希望在这个项目里使用一个固定的编译命令，就可以利用上文“局部变量”小节中提到的办法自定义局部变量 compile-command 为我们想要的编译命令。 如果我们在之前的基础上设置，会得到如下的 .dir-locals.el 文件：\n1;;; Directory Local Variables 2;;; For more information see (info \u0026#34;(emacs) Directory Variables\u0026#34;) 3 4((c++-mode . ((compile-command . \u0026#34;g++ main.cpp -g -o exec\u0026#34;) 5\t(flycheck-clang-language-standard . \u0026#34;c++11\u0026#34;)))) 但是显然，这里我们写死了源代码文件 main.cpp，对于一些特定小项目是可以的，但是对于刷算法题这种需求却并不好用，因为我们不同的题目是放在不同的源文件中，每个都单独可编译。为此，我们需要让 Emacs 自己为编译命令填写当前的源码文件（这里其实就是我们手动实现一个类似 VSCode 的 Code Runner 插件）。\n首先我们可以在 init.el （或者是任何你自己定义的 elisp 文件中）定义两个函数：\n1(defun file-name-only () 2 \u0026#34;Get the current buffer file name without directory.\u0026#34; 3 (file-name-nondirectory (buffer-name))) 4 5(defun file-name-only-noext () 6 \u0026#34;Get the currennt buffer file name without directory and extension.\u0026#34; 7 (file-name-sans-extension (file-name-only))) 前者可以获得当前所在 buffer 的文件名，后者则得到了文件名除去后缀名的名字（用来做可执行文件名）。\n随后我们设置 compile-command 为：\n1(concat \u0026#34;clang++ -g \u0026#34; (file-name-only) \u0026#34; -o \u0026#34; (file-name-only-noext)) 其中 concat 是一个字符串拼接函数，可以理解为：\n1\u0026#34;clang++ -g \u0026#34; + (file-name-only) + \u0026#34; -o \u0026#34; + (file-name-only-noext) 最终得到这样的 .dir-locals.el：\n1((c++-mode . ((compile-command . (concat \u0026#34;clang++ -g \u0026#34; 2\t(file-name-only) 3 \u0026#34; -o \u0026#34; 4\t(file-name-only-noext))) 5\t(flycheck-clang-language-standard . \u0026#34;c++11\u0026#34;)))) 这样当我们调用 compile 命令时，可以利用字符串拼接自动补全当前所在的源文件并编译成相应的可执行文件。注意其中的 -g 选项是用于 debug 的选项 。读者也可以直接修改 .dir-locals.el 文件，只不过括号比较多需要注意不要出错。\nLSP 前文提到，LSP 需要针对每个语言有一个后端程序提供分析功能。对于 C/C++ 笔者所使用的是 llvm 下的 clangd 工具，读者还可以选择 ccls。安装可以参照它的官网，简单来说，对于 macOS，安装了 llvm 就有了 clangd；对于 Debian/Ubuntu 可以直接用 apt 安装。\n每种语言的 language server 都被 lsp 插件官网贴心地罗列了出来。 对于项目需要一些特殊的编译选项，例如自定义头文件、库等，需要参照 clangd 的文档进行设置，简单来说，就是在项目目录下创建一个 compile_flags.txt 文件，把编译选项写在里面就好。写好后，clangd 在分析代码时就会使用这些选项了。\n对于 CMake 项目，CMake 可以生成 compile_commands.json 文件给 clangd 使用，参考 clangd 的文档。此外，也可以使用 cmake-ide 插件（但就不走 lsp 插件了）。对于 CMake 语法则可以安装 cmake-language-server。\nC/C++ 配置如下，其中 c-toggle-hungry-state 函数是为了在按下删除键时尽可能删除多余空白字符，例如缩进的空白、空行等，会自动删除到一个非空白字符，读者可以根据需要开启：\n1(use-package c++-mode 2 :functions ; suppress warnings 3 c-toggle-hungry-state 4 :hook 5 (c-mode . lsp-deferred) 6 (c++-mode . lsp-deferred) 7 (c++-mode . c-toggle-hungry-state)) 调试 Emacs 本身可以直接使用 M-x gdb 利用 gdb 进行调试。\n那么我们更希望使用 dap-mode， 笔者选择使用 llvm 下的 lldb-vscode 工具做后端进行调试。安装 llvm 后应该已经安装好了这个工具，否则手动安装就好。\n1(use-package dap-lldb 2 :after dap-mode 3 :custom 4 (dap-lldb-debug-program \u0026#39;(\u0026#34;/usr/local/opt/llvm/bin/lldb-vscode\u0026#34;)) 5 ;; ask user for executable to debug if not specified explicitly (c++) 6 (dap-lldb-debugged-program-function 7\t(lambda () (read-file-name \u0026#34;Select file to debug: \u0026#34;)))) 配置中明确指定了 lldb-vscode 的路径。这里的路径是 macOS 上通过 Homebrew 安装 llvm 的路径，其它平台的路径需要自行确定。\n除了 lldb-vscode，也可以使用其它方式如 vscode-cpptools、GDB 等，可以参考 dap-mode 的手册。\nmacOS 上（Linux 未测试）直接使用默认的 lldb 做 debug 会提示 Failed to load MI Debugger。这是因为 llvm-mi 被移出了 llvm 项目成为了一个单独项目，所以并未一同安装。 需要克隆源码安装一下（请事先选择好一个合适的存放目录进行操作）：\n1$ git clone https://github.com/lldb-tools/lldb-mi.git 2$ mkdir -p lldb-mi/build 3$ cd lldb-mi/build 4$ cmake .. 5$ cmake --build . 6$ ln -s $PWD/src/lldb-mi /usr/local/bin/lldb-mi 最后的链接命令可以改成你觉得合适的其它路径，只要在环境变量中就好。安装好后，就可以直接使用 lldb。macOS 上 dap-mode 使用 gdb 会有问题，笔者也暂未解决。\nRust Rust 得益于其本身完善的工具链，相比之下要简单很多，直接安装 rust-mode 和 cargo 插件，M-x cargo-process-run 就可以执行 cargo run。其余命令也都以 cargo- 为前缀，可以参考官方主页。\n1(use-package rust-mode 2 :ensure t 3 :functions dap-register-debug-template 4 :bind 5 (\u0026#34;C-c C-c\u0026#34; . rust-run) 6 :hook 7 (rust-mode . lsp-deferred) 8 :config 9 ;; debug 10 (require \u0026#39;dap-gdb-lldb) 11 (dap-register-debug-template \u0026#34;Rust::LLDB Run Configuration\u0026#34; 12 (list :type \u0026#34;lldb\u0026#34; 13\t:request \u0026#34;launch\u0026#34; 14\t:name \u0026#34;rust-lldb::Run\u0026#34; 15\t:gdbpath \u0026#34;rust-lldb\u0026#34; 16\t:target nil 17\t:cwd nil))) 18 19(use-package cargo 20 :ensure t 21 :hook 22 (rust-mode . cargo-minor-mode)) LSP 方面，笔者使用了 rust-analyzer，其安装方法在主页上有详细说明。这里 debug 我使用的是 rust-lldb，因为 macOS 上使用 rust-gdb 有一些问题。事实上，rust 本质就是使用 lldb，所以和 C/C++的情况一样。另外，这篇博客有介绍更多详细的 Rust 相关配置。相信现阶段能使用 Rust 的都是有些编程经验的人，所以这里就不做赘述了。\nPython 运行 Python 的运行主要考虑与它的 REPL 的配合以及虚拟环境的切换。前者是 Emacs 自带的基础功能，后者可以安装插件 pyvenv 进行管理。笔者平日使用 miniconda 做 Python 的环境管理（F.Y.I., miniconda 是 anaconda 的最精简版），如果你使用 anaconda，只需要改个名字；如果你使用 Python 本身的 virtualenv，pyvenv 插件更是直接支持。\n1(use-package python 2 :defer t 3 :mode (\u0026#34;\\\\.py\\\\\u0026#39;\u0026#34; . python-mode) 4 :interpreter (\u0026#34;python3\u0026#34; . python-mode) 5 :config 6 ;; for debug 7 (require \u0026#39;dap-python)) 8 9(use-package pyvenv 10 :ensure t 11 :config 12 (setenv \u0026#34;WORKON_HOME\u0026#34; (expand-file-name \u0026#34;~/miniconda3/envs\u0026#34;)) 13 ;; (setq python-shell-interpreter \u0026#34;python3\u0026#34;) ; （可选）更改解释器名字 14 (pyvenv-mode t) 15 ;; （可选）如果希望启动后激活 miniconda 的 base 环境，就使用如下的 hook 16 ;; :hook 17 ;; (python-mode . (lambda () (pyvenv-workon \u0026#34;..\u0026#34;))) 18) 读者需要把这里的 ~/miniconda3 路径换成自己的路径，一般默认或者在用户目录下，形如 ~/anaconda3；或者在根目录下，形如 /anaconda3。使用 virtualenv 的话则不需要这行配置。\n有了 pyvenv，我们打开 Python 项目，如果想要切换环境，就输入命令 M-x pyvenv-workon，它会列出所有可以切换的环境，配置中的设置就是为了能让 pyvenv 找到我们的 miniconda 环境。\n想要使用 REPL，首先打开一个 Python 文件，然后使用快捷键 C-c C-p 调用命令 run-python，启动 Python 解释器，Emacs 会弹出一个名为 Python 的 buffer，就是 Python 的 REPL。随后我们光标放在 Python 文件的 buffer 中，可以选中一部分代码，或者不选表示全部代码，按 C-c C-c 调用命令 python-shell-send-buffer，把选中的代码发送到 REPL 中，此时 Python buffer 中就会相应地执行了这些代码。\n此外，对于 IPython Notebook 文件（.ipynb），有一个 emacs-ipython-notebook 插件可以提供支持，但笔者未使用过，在此不做评价。\nLSP Python 的 language server 比较多，包括 [python-language-server（pyls）](https://github.com/python- lsp/python-lsp-server)、Jedi、Microsoft Python Language Server 和 Pyright。pyls 普遍评价是比较慢，所以不推荐使用。后三个读者可以根据自己喜好选择。笔者选择了评价较好的 Pyright。可以通过 pip3 install pyright 来手动安装。Emacs 中的相应配置如下：\n1(use-package lsp-pyright 2 :ensure t 3 :config 4 :hook 5 (python-mode . (lambda () 6\t(require \u0026#39;lsp-pyright) 7\t(lsp-deferred)))) Python 的各种框架也基本都有 Emacs 插件提供支持，读者按需安装就好。\n注意 ，在图形界面中，尤其是 macOS 上，可能会出现明明安装了 pyright 但是 lsp 提示无法找到该命令的情况，遇到这个问题，请记得安装上面“环境变量” 小节的插件 exec-path-from-shell 。\n调试 使用 dap-mode 调试前需先手动通过 pip 安装 python3 -m pip install ptvsd。\n工作区管理 对于涉及多个项目的更复杂的任务，我们需要一个工作区（workspace）来进行管理和切换。treemacs 为我们提供了这样的功能。如果读者不需要工作区管理这样复杂的功能，而只是想要一个树形文件结构显示，那么可以考虑使用 neotree。\n1(use-package treemacs 2 :ensure t 3 :defer t 4 :config 5 (treemacs-tag-follow-mode) 6 :bind 7 (:map global-map 8 (\u0026#34;M-0\u0026#34; . treemacs-select-window) 9 (\u0026#34;C-x t 1\u0026#34; . treemacs-delete-other-windows) 10 (\u0026#34;C-x t t\u0026#34; . treemacs) 11 (\u0026#34;C-x t B\u0026#34; . treemacs-bookmark) 12 ;; (\u0026#34;C-x t C-t\u0026#34; . treemacs-find-file) 13 (\u0026#34;C-x t M-t\u0026#34; . treemacs-find-tag)) 14 (:map treemacs-mode-map 15\t(\u0026#34;/\u0026#34; . treemacs-advanced-helpful-hydra))) 16 17(use-package treemacs-projectile 18 :ensure t 19 :after (treemacs projectile)) 20 21(use-package lsp-treemacs 22 :ensure t 23 :after (treemacs lsp)) 配置好后，我们可以使用 C-x t t 调出 treemacs，用 M-0 在我们的代码 Buffer 和 treemacs 边栏之间切换。当我们光标进入 treemacs 边栏时，可以按问号 ? 来调出帮助。\n我们可以使用 treemacs-create-workspace 来创建一个新的工作区。它会在你当前光标所在处打出一个小窗提示你输入 “Workspace name”，起个合适的名字。创建好后，我们在 treemacs 边栏中输入 C-c C-p a 调用 treemacs-add-project-to-workspace 来添加一个项目路径，用 C-c C-p d 去除工作区选中的项目。这些都可以在 ? 显示的帮助中找到。想要切换工作区时，使用 treemacs-switch-workspace 命令。\n由于我们安装了 treemacs-projectile，我们也可以使用 treemacs-projectile 命令将我们 projectile 当中保存过的项目直接导入到 treemacs 中。\n此外，我们还可以调用 treemacs-edit-workspaces 来通过配置文件来修改我们的工作区设置，修改完成后用 treemacs-finish-edit 命令或 C-c C-c 结束编辑。它会自动检查语法。（ps：所使用的语法是 Emacs org-mode，一个 Emacs 内部的笔记系统，可以近似理解为高级 markdown，后续教程会做介绍）。\ntreemacs 不仅能够显示文件，还会显示其中的符号，包括函数定义、结构体定义等等。配置中的 (treemacs-tag-follow-mode) 就是希望 treemacs 始终跟随着我们代码光标所在位置进行移动。\n最后，? 显示出的帮助是 treemacs-common-helpful-hydra，我们可以按 / 或调用 treemacs-advanced-helpful-hydra 来显示出更多帮助，包括了对文件的操作和对工作区的操作。\ntreemacs 正常情况不会根据我们打开的 Buffer 不同而切换项目或工作区。其原因在于有时候我们只是打开一些额外的文件，并不希望工作区也进行转变。而大多数情况，我们也确实并不需要频繁切换工作区，所以我们主动去调用 treemacs-switch-workspace 就好。如果读者觉得这样过于繁琐，也可以开启一个 treemacs-project-follow-mode，它会根据我们的文件跳转到相应的项目中。 或者直接使用本节开头提到的 neotree 插件。\ntreemacs 的边栏是一个固定在 Buffer 内的 frame， 所以操作起来有些特殊。 终端 Emacs 内想要使用 Shell 可以直接调用 M-x shell 即可打开你的默认 Shell。使用 Shell 主要注意操作上，我们不再使用方向键来回滚历史命令，而是通过 M-p 和 M-n 来翻看命令。\n此外 Emacs 还特别打造了 eshell 作为 Emacs 的专用 Shell，但笔者几乎没有使用所以只做简要介绍。首先要明确 eshell 是个 shell 而不是个终端，所以我们不能指望它可以处理各种终端控制序列、丰富的色彩等等（这些应该由 Emacs 本身来完成），而应类比为 bash、zsh、fish 等之间的关系。eshell 最特别的是提供了对 Emacs Lisp 的直接支持，可以直接输入 Lisp 语句，甚至可以省略外部括号。此时读者可能会意识到，eshell 其实就是把各种命令打包成了 Emacs Lisp 的函数。也因此，可以把 eshell 作为一个Lisp 解释器，完成一些简单的计算任务等等都是可以的。同时，eshell 与 Emacs 的互动更密切，例如我们平时用 cat 命令组合 less 来查看文件，到了 eshell 可以使用 view-file 命令直接用 Emacs 的 buffer 查看文件，更方便配合 Emacs 的语法高亮等功能。\n一些稍微详细的介绍可以查看这个博客，更多细节就请参照官方文档了。\n远程访问 Emacs 本身有一个 tramp 功能可以实现远程 ssh 访问。无需任何配置，使用 C-x C-f 打开文件时，删除掉所有路径，只留下一个斜杠 /，然后输入成 /ssh:user@address:，后面接远程服务器上的目录，就可以访问到相应的远程服务器的相应文件或目录。如果在 ~/.ssh/config 中有配置 Host 名称，也可以直接输入名称 /ssh:hostname:。\n如果需要代理才能访问，请参考 基本配置-MELPA 中的代理配置：\n1(setq url-proxy-services \u0026#39;((\u0026#34;no_proxy\u0026#34; . \u0026#34;^\\\\(192\\\\.168\\\\..*\\\\)\u0026#34;) 2 (\u0026#34;http\u0026#34; . \u0026#34;\u0026lt;代理 IP\u0026gt;:\u0026lt;代理端口号\u0026gt;\u0026#34;) 3 (\u0026#34;https\u0026#34; . \u0026#34;\u0026lt;代理 IP\u0026gt;:\u0026lt;代理端口号\u0026gt;\u0026#34;))) 但是，虽然可以远程编辑，却并不能继续使用以上大部分功能，因为这些插件都是安装在本地的，而源代码和项目都在远程服务器上。VSCode 对此的解决办法是可以在远程服务器也安装一遍这些插件。对 Emacs 来说，其实只要把 ~/.emacs.d 目录复制到远程服务器上，然后在上面安装一个 Emacs，就可以直接在终端中使用远程的 Emacs 了，毕竟我们用 Emacs 本来就不需要鼠标。这样可能比远程访问来得更加简单好用。\n","link":"https://pavinberg.github.io/emacs-book/zh/development/","section":"","title":"插件：编程开发类"},{"body":"本文简单介绍一下如何为 Emacs 配置外观和主题，让 Emacs 成为一个赏心悦目的编辑器。\n本文首先简要介绍 Emacs 外观的概念和手动配置方式，之后介绍一些其他人设计好的主题供读者选择。外观的配置每个人有每个人的偏好，本文只介绍基本的配置逻辑，具体选择什么样的配置读者可以自己拓展搜索。\n初识配置 Face Emacs 中掌管显示的专用名词是 Face，例如对文字来说，其字体、字号、颜色、背景都称为 Face。\n想要配置 Face，输入命令 M-x customize-face 然后输入相应的 Face 名称即可自定义。那么如何知道 Face 的名称呢？在界面中输入 M-x list-faces-display 就可以显示当前界面下所有的 Face 的名字及颜色。例如，我们想更改光标的颜色，可以输入 \u0026quot;cursor\u0026quot;，就得到了类似下图所示的界面。\n这里 “Cursor face:“ 后有一块白色的矩形，那便是笔者 Emacs 中光标方块的颜色。下面的 “State” 表示这个 Face 是被谁设置了，笔者使用了主题，光标颜色由主题指定，这里就显示 “THEMED”；读者如果从未配置，这里会显示 ”STANDARD“，即”标准“，也就是默认的标准颜色。再下面是一段对这个 Face 的介绍。最后是可以配置的属性（Attribute），属性有很多，但只展示配置过的属性，对于 Cursor 来说，主要就是背景颜色，所以这里显示了 “Background”。点 “Choose” 就会列出一系列颜色供用户选择。点 “Show All Attributes“ 可以列出所有属性，包括字体、字号、加粗、斜体等等（但正如介绍中所说，对 Cursor 来说别的属性没有意义，所以这里修改别的也是没用的）。最后，点上方的 “Apply”就是应用当前的设置预览效果，但不保存设置；点 ”Apply and Save“ 就是应用并保存了。\n除了使用M-x list-faces-display 列出当前界面所有的 Face 外，还可以使用快捷键 C-u C-x = 调用带前缀参数的 what-cursor-position 命令，它会在新的窗口中显示光标所在位置的界面信息，其中包括了 Face。\n更通用的设置方式则是直接使用 Customization 进行搜索查找。强调一下，Customization 本身并不只包含关于 Face 的设置，各种变量都可以用它更改。进入 Customization 对首页可以输入命令 M-x customize，可以点选其中的 “Face” 进入关于 Face 的设置，其中有罗列所有的 Face 分类。例如对于背景颜色这种设置，可以直接选 “Basic Faces“，里面的 “Default face” 的 “Background” 就是控制 Emacs 背景的属性了。读者当然也可以直接用搜索框直接搜索。\n读者在使用命令行 Emacs 时，可能并没有很多可以选择的颜色，这很可能是因为读者所使用的终端不支持显示很多颜色。建议读者首先使用较为现代的终端程序，并且打开其中的色彩选项，例如 ”xterm-256“ 之类的。 配置 Custom 文件 那么我们的自定义设置究竟是保存到了哪里呢？当读者保存了上述自定义配置后，默认会在你的初始化文件（如 ~/.emacs.d/init.el）的末尾添加一段代码，类似：\n1(custom-set-variables 2 ;; custom-set-variables was added by Custom. 3 ;; If you edit it by hand, you could mess it up, so be careful. 4 ;; Your init file should contain only one such instance. 5 ;; If there is more than one, they won\u0026#39;t work right. 6 (custom-set-faces 7 ;; custom-set-faces was added by Custom. 8 ;; If you edit it by hand, you could mess it up, so be careful. 9 ;; Your init file should contain only one such instance. 10 ;; If there is more than one, they won\u0026#39;t work right. 11 ; 一些 Face 配置 12 )) 正如注释中所言，这段代码是由 Custom 系统自动维护的，读者轻易不要手动修改，否则会导致混乱。但是也可以看出，这里说到底也就是普通的 Emacs Lisp 代码，如果读者熟悉 Emacs Lisp，也不用对此非常畏惧。\n部分读者可能会提出，Custom 如此修改初始化文件，把初始化文件弄的不美观了；或者如果用户有时候在本机使用图形界面 Emacs，有时候在服务器上使用命令行 Emacs，二者希望进行不同的 Custom 设置但又不想维护两组 Emacs 配置，该如何操作呢？\n事实上，这段配置可以单独放在一个文件中，比如建一个 ~/.emacs.d/custom.el 文件，把上方的代码块完全剪切到其中，然后在配置文件如 ~/.emacs.d/init.el 中写入：\n1(setq custom-file \u0026#34;~/.emacs.d/custom.el\u0026#34;) 2(load custom-file) 这里设置变量 custom-file 改成我们自定义的文件名，然后加载这个文件，即可让 Custom 不再干扰我们的 ~/.emacs.d/init.el 文件，而把改动都写入 ~/.emacs.d/custom.el。\n读者更可以利用前面所学的模块化配置的方法，新建一个 ~/.emacs.d/lisp/init-theme.el 文件，把这两句代码写进去后，在 ~/.emacs.d/init.el 中 require 导入。\n对于想要区分多个场景下的 Custom 配置，可以参考如下 init-theme.el 的配置：\n1(setq custom-nw-file (expand-file-name \u0026#34;custom-nw.el\u0026#34; user-emacs-directory)) 2(setq custom-gui-file (expand-file-name \u0026#34;custom-gui.el\u0026#34; user-emacs-directory)) 3 4(if (display-graphic-p) 5\t(progn 6\t(setq custom-file custom-gui-file) 7 ; (add-to-list \u0026#39;default-frame-alist \u0026#39;(ns-appearance . dark)) ; macOS 下让窗口使用暗色主题 8\t;; other settings 9 ) 10 (progn 11\t(setq custom-file custom-nw-file) 12 ;; other settings 13\t)) 14 15(load custom-file) 如此在图形界面时使用 ~/.emacs.d/custom-gui.el 而在命令行时使用 ~/.emacs.d/custom-gui.el。\n配置主题 Emacs 的主题非常多，读者只需要在搜索引擎中搜索 “Emacs 主题”，或在国外搜索引擎中搜索 “Emacs themes” 就能得到非常多的结果。比较全的网站有 Emacs Themes Gallery 和 GitHub Topics：emacs-theme。\n举个例子，笔者比较喜欢 Dracula 主题，通过 Gallery 网站找到 Dracula 的主页。其中写着只需要输入命令 M-x package-install \u0026lt;RET\u0026gt; dracula-theme 即可安装。随后在配置文件 ~/.emacs.d/init-themes.el 的合适位置写入：\n1(load-theme \u0026#39;dracula t) 就可以使用 Dracula 主题了。\n此外，笔者也非常喜欢 Doom Emacs 的主题，本教程虽然使用的是 Vanilla Emacs， 但也有插件把 Doom Emacs 的主题借鉴了过来。不仅如此，诸如 Atom、Monokai 也都有相应的实现，读者只需要寻找相应的主页进行安装即可。\n在此分享一下笔者所使用的 Doom Emacs 主题，用到了 doom-themes 包，笔者选择了 doom-monokai-octagon 主题：\n1(use-package doom-themes 2 :ensure t 3 :config 4 ;; Global settings (defaults) 5 (setq doom-themes-enable-bold nil ; if nil, bold is universally disabled 6\tdoom-themes-enable-italic t) ; if nil, italics is universally disabled 7 (load-theme \u0026#39;doom-monokai-octagon t) 8 (doom-themes-treemacs-config)) doom-themes 中本身就有很多主题可选，读者可以根据喜好选择。 注意最好搭配下文的 all-the-icons 一同使用。\n配置图标 图形界面的 Emacs 可以安装一个 [all-the-icons](https://github.com/domtronn/all-the- icons.el) 插件来为 Emacs 提供图标的支持，对于命令行 Emacs 来说如果终端能够支持这些图标字体，也是可以使用的。首先添加配置：\n1(use-package all-the-icons 2 :if (display-graphic-p)) 重启 Emacs 后安装字体：M-x all-the-icons-install-fonts。\n这些图标可以用在许多地方，例如自动补全框、文件列表等等，有些搭配相应的主题，如上文的 doom-themes 插件可以自动配置图标，其它可参考插件的 Wiki，读者可根据需要自行配置合适的图标。\nmode-line mode-line 的显示非常见仁见智，有的人喜欢花哨的，有的人喜欢简约的。笔者属于后者，所以没有配置很复杂的图形显示。mode-line 可以使用 powerline、spaceline 等。powerline 在 zsh 里比较流行，spaceline 则是从 Spacemacs 衍生出来的。\n这里再次提一下在插件：功能优化类里提及的插件 smart-mode-line 的额外配置。mode-line 由于会显示出当前的所有次模式（minor mode），很混乱，而 smart-mode-line 可以规整 mode-line， 但用起来还是会发现经常一些不太重要的 minor mode 被显示出来，重要的反而被排在了后面。这时候我们可以隐藏一部分 minor mode。\n隐藏 minor mode 实际上是由另一个插件 rich-minority 来完成的，但安装了 smart-mode-line 之后已经被一起安装好了。还有一个类似功能的插件是 diminish，读者可以自行选择其中之一。\n1(use-package smart-mode-line 2 :ensure t 3 :init 4 ; (setq sml/no-confirm-load-theme t) ; avoid asking when startup 5 (sml/setup) 6 :config 7 (setq rm-blacklist 8 (format \u0026#34;^ \\\\(%s\\\\)$\u0026#34; 9 (mapconcat #\u0026#39;identity 10 \u0026#39;(\u0026#34;Projectile.*\u0026#34; \u0026#34;company.*\u0026#34; \u0026#34;Google\u0026#34; 11\t\u0026#34;Undo-Tree\u0026#34; \u0026#34;counsel\u0026#34; \u0026#34;ivy\u0026#34; \u0026#34;yas\u0026#34; \u0026#34;WK\u0026#34;) 12 \u0026#34;\\\\|\u0026#34;)))) 相比之前，就是添加了一个 config，把一些不想被显示的 minor mode 加入黑名单。看起来有些复杂但其实读者无需关心细节，这里的 format 和 mapconcat 只是在做字符串操作，设法把用户罗列的 minor mode 名字拼接成一整个字符串。读者只需要修改其中的那个列表：\n1\u0026#39;(\u0026#34;Projectile.*\u0026#34; \u0026#34;company.*\u0026#34; \u0026#34;Google\u0026#34; 2 \u0026#34;Undo-Tree\u0026#34; \u0026#34;counsel\u0026#34; \u0026#34;ivy\u0026#34; \u0026#34;yas\u0026#34; \u0026#34;WK\u0026#34;) 其中每个字符串可以是一个正则表达式，列出不希望显示在 mode-line 的 minor mode 名字即可。这里想要隐藏的分别是：projectile、company、google-this、undo-tree、counsel、ivy、yasnippet 和 which-key 。\n不得不承认，对于图形显示来说，Doom Emacs 和 Spacemacs 有更为丰富的实践，本文的 Vanilla Emacs 需要向它们多多取经。读者也可以多关注一下两个发行版的优秀插件。\n","link":"https://pavinberg.github.io/emacs-book/zh/theme/","section":"","title":"外观与主题"},{"body":"本文将介绍一些除编程本身外 Emacs 作为一个代码编辑器还能为开发者做什么样的事情，包括：\n笔记类任务：Markdown、LaTeX 中文编辑 计算器： calc Emacs server ChatGPT 协作 本文可能会不断更新。\n笔记 Markdown 笔记类任务现在比较流行 Markdown，一种非常简单易学的标记语言。\n程序员们经常与 Markdown 打交道，所以如果你是一位新人程序员还不了解 Markdown，强烈建议你学习一下。 Markdown 如今已十分流行，Markdown 编辑器数不胜数，各具特色。要说 Emacs 有什么能完全胜出其它 Markdown 编辑器的优势，笔者认为可能只有下文提到的“中文支持”功能。此外，对于大部分程序开发而言，Markdown 主要是参与写一些 README.md 等文档，这样如果代码都是在 Emacs 中编写和浏览，文档也用 Emacs 来写会更为方便、操作更为统一。\n因此，笔者对 Emacs 中的 Markdown 的态度是轻度使用，不希望费力配置，甚至不想记太多操作，所以本文只介绍 Emacs 自带的功能 markdown-mode。\n无需任何配置，打开 .md 文件就会自动使用 markdown-mode，Emacs 会提供一些语法高亮，还有一些语法的快捷键。例如插入代码块可以输入命令 M-x markdown-insert-gfm-code-block 然后输入想要输入的编程语言名字即可，其快捷键是 C-c C-s C。所有相关命令都是以 markdown-insert- 做前缀的， 读者按需记几个常用的就好，毕竟 Markdown 语法已经很简单了，也没必要记太多快捷键。\n此外还有一些方便跳转的快捷键，例如：\nC-c C-n 调用 markdown-outline-next 可以快速跳到下节，C-c C-u 调用 markdown-outline-up 跳到上一节。 C-c C-f 调用 markdown-outline-next-same-level 跳到下一个同级章节，C-c C-b 调用 markdown-outline-previous-same-level 跳到上一个同级章节。 其它功能的命令也都以 markdown- 为前缀，读者可以自行探索。\n想要预览 Markdown，可以输入 M-x markdown-live-preview-mode 或输入快捷键 C-c C-c l 就可以在另一个窗口里预览 。这个功能应当至少需要 Emacs \u0026gt;= 26 的版本（未完全确认）。笔者认为自带的预览功能比较一般，所以只适合轻度使用。\n如果确实认为自带的功能很简陋，读者可以尝试 Wiki 中提及的 impatient-mode、livedown-mode 和 realtime-preview。impatient-mode 根据介绍是一个基于 Emacs Lisp 的为 HTML 提供预览的工具，但可以稍微改造一下用于 Markdown 的预览。 其它两个模式分别需要依赖 Node.js 和 Ruby 这类外部工具，读者按需选择就好。\nLaTeX LaTeX 是一个功能极其强大的排版系统，一般来说日常无需使用如此重量级的工具，笔者仅在写一些比较重要的报告和论文时才会使用。如果没有这类需求可直接略过本节。\n事实上 LaTeX 的编辑器也很多，包括 VSCode 也可以提供良好的体验。笔者使用 Emacs 作为 LaTeX 编辑器其实更多是为了结合下文提到的“中文支持”功能，用以编写中文的 LaTeX。其余功能与 VSCode 大同小异。 首先应当正常手动安装好 LaTeX 并保证能正常使用。Emacs 中则需要安装 AUCTeX，一个专门的包。可以通过 M-x package-install \u0026lt;RET\u0026gt; auctex 安装。\n随后打开 .tex 文件时会进入 TeX-mode（大小写敏感）， 提供了语法高亮。一些可以辅助插入特定格式的快捷键以 latex- 为前缀，读者自行探索就好。\nLaTeX 编译成的 PDF 也可以在 Emacs 中打开。需要安装 pdf-tools 插件。依然建议从 MELPA 安装比较方便，可使用如下配置：\n1(use-package pdf-tools 2 :ensure t 3 :init 4 (pdf-loader-install)) 5 (add-hook \u0026#39;pdf-view-mode-hook (lambda () (display-line-numbers-mode -1))) 6 7(defun pdf-view-kill-rmn-ring-save () 8 \u0026#34;Copy the region to the `kill-ring\u0026#39; after remove all newline characters.\u0026#34; 9 (interactive) 10 (pdf-view-assert-active-region) 11 (let* ((txt (replace-regexp-in-string \u0026#34;\\n\u0026#34; \u0026#34; \u0026#34; 12 (car (pdf-view-active-region-text))))) 13 (pdf-view-deactivate-region) 14\t(kill-new txt))) 15 16(use-package pdf-view-mode 17 :bind 18 (\u0026#34;C-c C-w\u0026#34; . pdf-view-kill-rmn-ring-save)) 安装后即可在 Emacs 中打开 PDF 文件，同时笔者定义了一个函数 pdf-view-kill-rmn-ring-save 并绑定到快捷键 C-c C-w 上，该命令可以在选中 PDF 的一段文字后将其复制出来，同时去掉其中的回车。\npdf-tools 提供了很多可以快速浏览 PDF 的快捷键，可参考官方主页。\n编译 LaTeX 可以在 .tex 文件上按下 C-c C-c 然后选择 \u0026quot;LaTeX\u0026quot;。选择 \u0026quot;BibTeX\u0026quot; 或 “Biber” 可以编译引文 .bib。切换编译引擎可以设置 TeX-engine 变量，其变量文档中有列出可选值，如 “xetex” 可以切换成 XeLaTeX。由于编译是直接编译当前 TeX 文件，对于有多个 .tex 文件的项目，可以设置一个主 TeX 文件，对应 TeX-master 变量。这些可以利用插件：编程开发提到的局部变量来进行设置。例如这样的 .dir-locals.el：\n1;;; Directory Local Variables 2;;; For more information see (info \u0026#34;(emacs) Directory Variables\u0026#34;) 3 4((latex-mode . ((TeX-engine . xetex) 5\t(TeX-master . \u0026#34;/path/to/main/tex\u0026#34;)))) 中文支持 这里主要是指对中文内容提供两点支持：\n中文分词：Emacs 可以做到 M-b、M-f 来按中文词进行光标移动。这种支持对于快速编辑中文、保持 Emacs 的操作一致性非常重要。默认情况下，对一段中文文本按下 M-b/M-f 会直接跳到上一个/下一个标点符号，失去了以词为单位移动的意义。 中英文符号的自定义切换。如果读者写过带公式、代码块的中文 Markdown/LaTeX，一定会发现有一件事非常非常令人厌烦，就是中英文输入法的切换。在输入内容和标点时需要中文字符，但在输入符号时需要英文字符，经常写起来会被这些切换搞得头脑混乱。虽然可以利用编辑器的快捷键缓解问题，但不具有通用性，不尽如人意。 解决分词问题 笔者使用了 [emacs-chinese-word-segmentation](https://github.com/kanglmf/emacs- chinese-word-segmentation) 工具。该工具借助 jieba 分词实现了分词功能。这个插件没有放到 MELPA 等仓库，需要手动 clone 安装，参见其主页即可。\n笔者建议在 ~/.emacs.d/chinese/ 等目录下 clone 该项目，然后按照其主页的命令使用 make 进行编译。随后把其主页的配置内容放到合适的配置文件中去。在想要使用这个中文分词时，手动调用 cns-mode 就可以了。如果想要在某个特定项目中使用，那么可以加入到局部变量 .dir-locals.el 中，如：\n1((markdown-mode . ((eval . (cns-mode))))) Emacs 还有一个 pyim 插件，是一个内部中文输入法，能支持五笔、双拼等，安装了它后，也可以获得分词功能。但是 pyim 体验一般，而且毕竟是独立于系统的输入法的，在 Emacs 内外切换两个输入法不是很舒适，用户完全可以使用外部的选择众多的功能强大的输入法搭配 cns-mode，因此笔者并不推荐 pyim。 而 解决输入法切换问题 ，可直接利用 Emacs 的 keyboard-translate 功能，该功能可以实现把一个符号映射成另一个符号。笔者针对 Markdown 使用了如下设置：\n1(add-hook \u0026#39;markdown-mode-hook (lambda () 2\t(keyboard-translate ?¥ ?$) 3\t(keyboard-translate ?· ?`) 4\t(keyboard-translate ?～ ?~) 5 (keyboard-translate ?、 ?\\\\) 6\t(keyboard-translate ?｜ ?、) 7\t(keyboard-translate ?\\「 ?{) 8\t(keyboard-translate ?\\」 ?}) 9\t(keyboard-translate ?\\《 ?\u0026lt;) 10\t(keyboard-translate ?\\》 ?\u0026gt;))) 思路就是一些几乎不使用的中文字符直接映射成英文字符，以方便编写 Markdown。例如第一句，把人民币 ¥ 映射成美元 $，这样在中文输入时也可以直接按 shift+4 来输入 $ 符号，从而输入内联公式。同样的， · 也被映射为 ``` `` 由此方便输入行内代码。 为了能够方便输入反斜杠，把顿号 、 映射为 \\ 而把 ｜ 映射会 顿号 、（读者如果不喜欢这样操作可以去掉相应代码）。以此类推。\n这里的语法就是“问号+字符”，部分字符需要用反斜杠转义。\norg-mode org-mode 其实是 Emacs 中非常强大的笔记模式，在 Emacs 中使用的体验、功能的强大远超 Markdown。org-mode 的主要缺点是一方面需要一定的学习成本，另一方面只能在 Emacs 中使用，不方便直接分享。org-mode 具有非常独特的优势，建议读者了解一下，下一篇教程会为大家详细地抛砖引玉。\n计算器 写程序也是偶尔需要计算器的，例如算一算字节数、传输速率、做一做十六进制转化等。Emacs 内置了一个非常强大的计算器：calc。除了常见普通计算器的功能，还包括：\n复数运算 2～36 进制运算 质因数分解 线性代数、矩阵运算 微积分 方程求解 逆波兰表达式 与 GNUPLOT 对接画图 事实上笔者基本用不到多么高级的功能，主要是加减乘除、幂运算、进制转换等。本文就简要介绍一下基本使用逻辑。\n输入命令 M-x calc 启动计算器。 按 h T 可以打开教程。\n默认使用 RPN（Reverse Polish Notation，逆波兰表达式或称后缀表达式）。所谓 RPN 就是数字会以栈的形式依次放入，在输入运算符时数字出栈、计算、再把结果入栈。如果读者从未听说过后缀表达式，甚至连栈也没有听说过，那么直接只用普通的算数表达式就好。先输入单引号 '，然后就可以在 Minibuffer 中输入正常的表达式了。至于逆波兰表达式的学习，读者可以参考《数据结构》课程。\n如果是使用 RPN，那么例如计算 $ 2 + 3 \\times 4 $ 时需要依次输入：2、3、4、*、+。 Emacs 会维护一个栈供用户查看，如下图左侧，从下到上依次是栈底到栈顶。右侧可简单理解为历史记录。\n特别的，按 \u0026lt;backspace\u0026gt; 可以移除栈顶元素，按 \u0026lt;TAB\u0026gt; 可以交换栈顶的两个元素，按 M-\u0026lt;TAB\u0026gt; 可以把第三个元素拿出来重新放入栈顶，U 可以撤销操作。很多运算符也都有含义，例如 \u0026amp; 取倒数 ，^ 取幂等。\n人们的第一反应一般是觉得 RPN 非常的反常识，肯定不好用，但事实上，RPN 作为 calc 的默认模式还是有一定道理的，至少从笔者日常的体验来说，适应之后似乎确实更省事，毕竟也可以交换栈顶元素，每次可以只考虑局部的运算，然后一步步算出最终结果。普通的算式的话，则需要来回加小括号，或者把结果保存到临时变量中去以备使用。\n想要输入十六进制的数，例如 0xFE，只需要输入 16#fe ，其它进制也一样，N 进制就输入 N# 开头，后接数字即可。 N 的取值是 2～36（笔者推测之所以止步于三十六进制是因为 10 个数字+26 个字母共计 36 个字符）。\n运算结果默认显示为十进制，想要显示为 N 进制，输入 d r N。 此外，还有快捷输入：\n显示为十进制：d 0 显示为二进制：d 2 显示为十六进制：d 6 显示为八进制：d 8 Emacs server 由于 Emacs 的启动较慢，在命令行使用 Emacs 时，频繁启动关闭非常不方便。一种方式是启动后按 C-z 挂起 Emacs 回到 Shell，之后再输入命令 fg （Foreground 的缩写）回到 Emacs。\n这里介绍另一种方式。Emacs 为用户提供了一个 client-server 模式，用户可以设置开机启动 Emacs server 的守护进程，然后在需要使用 Emacs 编辑文件时，通过 Emacs client 打开 Emacs。由于 Emacs 已在后台启动，client 可以秒开 Emacs。\n手动启动，在 Shell 中输入：\n1$ emacs --daemon Emacs 就会在后台加载好，称为一个守护进程。\n之后想要打开文件 test.c 时，输入：\n1$ emacsclient test.c 如果希望开机自动启动 Emacs 守护进程，需要修改操作系统的启动项。Linux 上可使用 systemd，macOS 使用 launchctl， Windows 也可支持。读者直接参照 Wiki 中的 “Adding To OS Startup” 小节就好。\n图形界面的话，一般没必要使用这一功能，直接打开程序后不关闭就好了。\nChatGPT chatgpt-shell 可以在 Emacs 内通过交互式界面与 ChatGPT 通信。其使用方式非常简单，只需要根据其主页导入插件并设置 OpenAI key：\n1(use-package chatgpt-shell 2 :ensure t 3 :custom 4 ((chatgpt-shell-openai-key 5 (lambda () 6 (\u0026#34;abcdefg\u0026#34;))))) 然而这里 直接把密钥写进配置文件并不是一个好选择 ，因为大家通常会在云端备份自己的 Emacs 配置，会暴露自己的密钥。所以更推荐使用密码管理器，例如 Unix 平台上可以使用 pass，将密钥保存到 pass 中并进行这样的配置：\n1(use-package chatgpt-shell 2 :ensure t 3 :custom 4 ((chatgpt-shell-openai-key 5 (lambda () 6 (auth-source-pass-get \u0026#39;secret \u0026#34;openai-key\u0026#34;))))) 对于 macOS 来说，则可以利用自带的钥匙串。首先打开终端输入如下命令，其中把 \u0026quot;abcdefg\u0026quot; 换成你自己的 OpenAI Key：\n1$ security add-generic-password -a \u0026#34;openai key\u0026#34; -w \u0026#34;abcdefg\u0026#34; -s \u0026#34;api.openai.com\u0026#34; 然后定义一个读取钥匙串的辅助函数并进行配置：\n1(when *is-a-mac* 2 (defun osx-get-keychain-password (account-name) 3\t\u0026#34;Gets ACCOUNT-NAME keychain password from OS X Keychain.\u0026#34; 4\t(let ((cmd (concat \u0026#34;security 2\u0026gt;\u0026amp;1 \u0026gt;/dev/null find-generic-password -ga \u0026#39;\u0026#34; account-name \u0026#34;\u0026#39;\u0026#34;))) 5\t(let ((passwd (shell-command-to-string cmd))) 6\t(when (string-match (rx \u0026#34;\\\u0026#34;\u0026#34; (group (0+ (or (1+ (not (any \u0026#34;\\\u0026#34;\u0026#34; \u0026#34;\\\\\u0026#34;))) (seq \u0026#34;\\\\\u0026#34; anything)))) \u0026#34;\\\u0026#34;\u0026#34;) passwd) 7\t(match-string 1 passwd)))))) 8(when *is-a-mac* 9 (use-package chatgpt-shell 10\t:custom 11\t((chatgpt-shell-openai-key 12 (lambda () 13 ;; Here the openai-key should be the proxy service key. 14\t(osx-get-keychain-password \u0026#34;openai key\u0026#34;)))))) 这里引用它的主页的动图展示一下效果。\ngoogle-this 主页\n在 Emacs 内选中一段文本，按下 C-c / t 触发 google-this，即可搜索这段文本。注意这个插件一般是在本地机器才会使用，不适合在服务器上用。\n1(use-package google-this 2 :ensure t 3 :init 4 (google-this-mode)) ","link":"https://pavinberg.github.io/emacs-book/zh/tricks/","section":"","title":"实用小技巧"},{"body":"org-mode 是 Emacs 中非常强大的笔记模式，它的语法与 Markdown 类似，但 Emacs 为其赋予了很多功能，使用体验极佳，例如：\n章节折叠、跳转 方便的多状态、多层级 Todo List 丰富多样的链接引用功能 表格操作（甚至可以像 Excel 一样输入公式自动计算） 插入代码 导出成各种格式（Markdown、HTML、LaTeX 等） 依附于 Emacs 生态， 有着连贯的使用体验 org-mode 的主要缺点是一方面需要一定的额外的学习成本，另一方面只能在 Emacs 中使用，不方便直接分享（不过它可以导出成 Markdown、LaTeX、HTML 等）。\n读者可能会在很多地方看到 org-mode 的教程，但它们通常只教基本操作，而不介绍额外插件，更不告诉大家这么强大的工具该用在哪里、怎么用。本文的主要目的就是向大家简要介绍几个 org-mode 区别于其它主流笔记软件的“杀手锏”功能和插件，亦是笔者使用 org-mode 的主要用途。而 org-mode 的基本操作不复杂，已有很多教程，这里不会详细介绍。\n基础结构 org-mode 的文档非常简短，建议读者大致过一遍，至少看看目录。具体的快捷键在官方文档和各种教程中都有介绍，本文对此不啰嗦讲解，但还是针对结构进行一个非常简短的介绍。\n只要打开后缀名为 .org 的文件就会自动启动 org-mode。 语法和 Markdown 类似，只不过星号（*）开头是节，或可以说是标题：\n* 一级标题 ** 二级标题 *** 三级标题 通过按 \u0026lt;TAB\u0026gt; 和 S-\u0026lt;TAB\u0026gt; 可以对小节进行折叠，有利于查看。下面则是一个链接（可以不止是链接外部网页，也可以是本地文件）：\n[[https://github.com][GitHub]] #+ 开头的是该文件的属性，例如下面定义了 foo 属性的值为 bar。属性主要用于为 org-mode 提供高级功能。\n#+foo:bar org-mode 的配置自由度非常高，每个人都有自己的偏好，不复杂但可能会很长。因此建议根据基本配置中的内容将 org-mode 相关配置单独放到一个文件中（例如 ~/.emacs.d/lisp/init-org.el）。\n一般来说我们希望把自己的笔记整理到一起，变量 org-directory 表示了用户希望把笔记放到哪里，默认是 ~/org/ 目录，可以先进行如下设置：\n1(setq org-directory (file-truename \u0026#34;~/org/\u0026#34;)) Zettelkasten 笔记法 Zettelkasten 笔记法不是一个 org-mode 概念，而是一个很流行的笔记方式。大概的思想就是说，我们以前组织文件、书籍往往是按照内容组织成树形结构，自上而下有一级一级的文件夹，将知识分门别类归纳其中。但我们在学习的过程中，很难在一开始就把知识整理成体系，而是先零散学习，之后随着知识面的增加逐渐形成体系。因此，相比于自上而下的笔记方式，自下而上的方式更符合人的学习过程。此外，知识本身并不是个树形结构，知识之间有很多复杂的关联，应该形成一个知识网络，树形分门别类的方式限制了知识间的关联。简而言之，树形结构的组织方式更像是一个专业的学科综述，它不适合作为我们日常的笔记方法。\nZettelkasten 笔记法就是一个自下而上的知识网络的方式。我们在学习新事物时，先不要去管它到底应该属于哪个分支，而是记下来再说。而等到我们意识到这部分知识和我们已有的知识的关联时，就通过链接的方式与我们已有的知识网络连接起来，由此我们的知识网络就增加了一个新的节点。通过链接的方式，我们可以逐渐组织我们自己的知识网络，没有任何结构性的限制。\n那么在 Emacs 中，org-roam 就提供了这样的功能。以下是一个基本配置：\n1(use-package org-roam 2 :ensure t 3 :after org 4 :init 5 (setq org-roam-v2-ack t) ;; Acknowledge V2 upgrade 6 :config 7 (org-roam-setup) 8 :custom 9 (org-roam-directory (concat org-directory \u0026#34;roam/\u0026#34;)) ; 设置 org-roam 目录 10 :bind 11 ((\u0026#34;C-c n f\u0026#34; . org-roam-node-find) 12 (:map org-mode-map 13 ((\u0026#34;C-c n i\u0026#34; . org-roam-node-insert) 14 (\u0026#34;C-c n o\u0026#34; . org-id-get-create) 15 (\u0026#34;C-c n t\u0026#34; . org-roam-tag-add) 16 (\u0026#34;C-c n a\u0026#34; . org-roam-alias-add) 17 (\u0026#34;C-c n l\u0026#34; . org-roam-buffer-toggle))))) 在 org-roam 中，一个文件就是一个节点（node）。我们通过它提供的函数来新建文件，即按 C-c n f 调用 org-roam-node-find 来新建或打开一个笔记文件。新建时会让我们输入一个标题，这个后面随时可改，org-roam 会在我们指定的 org-roam-directory 里（这里设定的是 ~/org/roam/ 目录）新建一个带时间戳的文件作为实际存放这个笔记的文件，并在属性中绑定一个唯一的 ID，以防止标题重名。我们并不需要手动去访问这个目录里的文件，只需要用 C-c n f 来打开文件即可。org-roam 会自动和 ivy 或 helm 协作，提供补全功能。\n打开了一个笔记文件后，可以按 C-c n i 调用 org-roam-node-insert 来关联另一个节点。此外也可以对文件起别名、添加标签等等。其余功能都可以在文档中找到。对一个链接可以按 C-c C-o 调用 org-open-at-point 打开。\n此外，对于新建的笔记，我们可以自定义它的模板，例如笔者希望能记录每个笔记最后一次修改的时间，这里写了较多的辅助函数（pv/ 前缀的函数），但是逻辑就是在文件保存时（before-save）绑定一个 Hook（pv/org-set-last-modified），可以把当前的时间记录下来：\n1(use-package org-roam 2 :ensure t 3 :after org 4 :init 5 (setq org-roam-v2-ack t) ;; Acknowledge V2 upgrade 6 :config 7 (org-roam-setup) 8 ;;-------------------------- 9 ;; Handling file properties for ‘LAST_MODIFIED’ 10 ;;-------------------------- 11 (defun pv/org-find-time-file-property (property \u0026amp;optional anywhere) 12 \u0026#34;Return the position of the time file PROPERTY if it exists. 13 14When ANYWHERE is non-nil, search beyond the preamble.\u0026#34; 15 (save-excursion 16 (goto-char (point-min)) 17 (let ((first-heading 18 (save-excursion 19\t(re-search-forward org-outline-regexp-bol nil t)))) 20 (when (re-search-forward (format \u0026#34;^#\\\\+%s:\u0026#34; property) 21 (if anywhere nil first-heading) 22 t) 23 (point))))) 24 25 (defun pv/org-has-time-file-property-p (property \u0026amp;optional anywhere) 26 \u0026#34;Return the position of time file PROPERTY if it is defined. 27 28As a special case, return -1 if the time file PROPERTY exists but 29is not defined.\u0026#34; 30 (when-let ((pos (pv/org-find-time-file-property property anywhere))) 31 (save-excursion 32 (goto-char pos) 33 (if (and (looking-at-p \u0026#34; \u0026#34;) 34 (progn (forward-char) 35 (org-at-timestamp-p \u0026#39;lax))) 36 pos 37 -1)))) 38 (defun pv/org-set-time-file-property (property \u0026amp;optional anywhere pos) 39 \u0026#34;Set the time file PROPERTY in the preamble. 40 41When ANYWHERE is non-nil, search beyond the preamble. 42 43If the position of the file PROPERTY has already been computed, 44it can be passed in POS.\u0026#34; 45 (when-let ((pos (or pos 46 (pv/org-find-time-file-property property)))) 47 (save-excursion 48 (goto-char pos) 49 (if (looking-at-p \u0026#34; \u0026#34;) 50 (forward-char) 51 (insert \u0026#34; \u0026#34;)) 52 (delete-region (point) (line-end-position)) 53 (let* ((now (format-time-string \u0026#34;[%Y-%m-%d %a %H:%M]\u0026#34;))) 54 (insert now))))) 55 56 (defun pv/org-set-last-modified () 57 \u0026#34;Update the LAST_MODIFIED file property in the preamble.\u0026#34; 58 (when (derived-mode-p \u0026#39;org-mode) 59 (pv/org-set-time-file-property \u0026#34;last_modified\u0026#34;))) 60 :hook 61 (before-save . pv/org-set-last-modified) ; 保存文件时调用 62 :custom 63 (org-roam-directory (concat org-directory \u0026#34;roam/\u0026#34;)) ; 设置 org-roam 目录 64 ;; 自定义默认模板 65 (org-roam-capture-templates 66 \u0026#39;((\u0026#34;d\u0026#34; \u0026#34;default\u0026#34; plain \u0026#34;%?\u0026#34; 67 :if-new 68 (file+head \u0026#34;${slug}-%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34; 69 \u0026#34;#+title: ${title}\\n#+date: %u\\n#+last_modified: \\n\\n\u0026#34;) 70 :immediate-finish t))) 71 :bind ((\u0026#34;C-c n f\u0026#34; . org-roam-node-find) 72 (:map org-mode-map 73 ((\u0026#34;C-c n i\u0026#34; . org-roam-node-insert) 74 (\u0026#34;C-c n o\u0026#34; . org-id-get-create) 75 (\u0026#34;C-c n t\u0026#34; . org-roam-tag-add) 76 (\u0026#34;C-c n a\u0026#34; . org-roam-alias-add) 77 (\u0026#34;C-c n l\u0026#34; . org-roam-buffer-toggle))))) 笔者这里只有一个默认模板，如果用户设定了多个模板，在新建文件时就会询问用户想要用哪个模板新建，十分方便。\n任务管理 简介 org-mode 另一个用途是可以管理自己的任务清单。在毫无自定义配置时，写起来大概是这样的：\n相信很多读者会和笔者一开始一样心想：“这不就是一个很普通的 todo-list 嘛，这么简单的事情什么软件不能做？而且组织整理任务清单好麻烦的，没有这个习惯。”\n但事实上，任务管理是要搭配 org-agenda 一同使用。实际的使用方式是，用户在固定的一个或几个文件中写自己的任务清单，然后调用 org-agenda 命令，它会为我们整理一个漂亮的日程安排。其中可以选择很多种方式展示，例如过滤掉已完成的任务，按 Deadline 顺序显示等等。\n此外，每个任务可以不止是有“TODO”和”DONE”两种状态，而是自定义任何其它状态；org-mode 还提供了任务优先级功能。于是，就可以有这样的效果：\n笔者当时截图日期是 5 月 11 日周四的 12:20。可以看到，最开头是最高优先级的、也就是亟需完成的任务。紧接着，是前两天开始的 7 天时间的任务概览。其中，今天的任务会详细显示，还包括了红色的前两天超时未完成的任务，以及每周四的 18:30 预订了一个周期性的组会，处于“MEETING”状态。最下方是详细的普通优先级任务，其中第一条处于“WAITING”状态，因为这是笔者要投稿论文，需要在网站注册，但当时该注册网站尚未启动，所以需要等待它开通。右侧两个冒号间的内容则是各个任务的标签（tag），可用于筛选任务。\n可以看到，org-mode 结合 org-agenda 后，不仅仅是一个简单的 todo-list，还是一个日历，还可以具备多状态、多优先级、多标签。具备多状态的好处就是，如果一个任务只有完成和没完成两个状态，那如果我们需要等待别人完成我们才能开始时，就需要自己在脑袋里记着，而现在我们有了“WAITING”状态，就可以显式标记出来。同时它还可以是多层级的，大任务下可以写小任务，有利于拆解复杂的任务。而会议其实不算是一个待办事项，所以还有额外的“MEETING”状态。任务可以被取消，所以还有个“CANCELD”状态。\n配置 笔者的配置主要来自于这篇博客和这篇博客。在 :init 中，笔者设置了 pv/org-agenda-files 为目录 ~/org/Agenda/，这表示“该目录下的所有文件都是用于写 todo-list 的，在使用 org-agenda 时需要对它们进行读取”。随后新建一个文件 ~/org/Agenda/agenda.org 用来写自己的 todo-list，调用 C-c a d 就可以展示类似上图的任务列表视图。\n1(setq org-directory (file-truename \u0026#34;~/org/\u0026#34;)) 2(setq pv/org-agenda-files `(,(concat org-directory \u0026#34;Agenda/\u0026#34;))) 3 4(use-package org 5 :init 6 (require \u0026#39;org-indent) 7 :config 8 (defun pv/init-org-hook () 9\t(setq truncate-lines nil) 10\t(org-toggle-pretty-entities)) ; display LaTeX symbols 11 (defun pv/org-skip-subtree-if-priority (priority) 12\t\u0026#34;Skip an agenda subtree if it has a priority of PRIORITY. 13 14PRIORITY may be one of the characters ?A, ?B, or ?C.\u0026#34; 15\t(let ((subtree-end (save-excursion (org-end-of-subtree t))) 16 (pri-value (* 1000 (- org-lowest-priority priority))) 17 (pri-current (org-get-priority (thing-at-point \u0026#39;line t)))) 18 (if (= pri-value pri-current) 19 subtree-end 20\tnil))) 21 (defun pv/org-skip-subtree-if-habit () 22\t\u0026#34;Skip an agenda entry if it has a STYLE property equal to \\\u0026#34;habit\\\u0026#34;.\u0026#34; 23\t(let ((subtree-end (save-excursion (org-end-of-subtree t)))) 24 (if (string= (org-entry-get nil \u0026#34;STYLE\u0026#34;) \u0026#34;habit\u0026#34;) 25 subtree-end 26\tnil))) 27 :hook 28 (org-mode . pv/init-org-hook) 29 :custom 30 (org-hide-leading-stars t \u0026#34;clearer way to display\u0026#34;) 31 (org-startup-with-inline-images t \u0026#34;always display inline image\u0026#34;) 32 (org-image-actual-width 600 \u0026#34;set width of image when displaying\u0026#34;) 33 (org-outline-path-complete-in-steps nil) 34 (org-todo-keywords 35 (quote ((sequence \u0026#34;TODO(t)\u0026#34; \u0026#34;NEXT(n)\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(d)\u0026#34;) 36\t(sequence \u0026#34;WAITING(w@/!)\u0026#34; \u0026#34;|\u0026#34; \u0026#34;CANCELLED(c@/!)\u0026#34; \u0026#34;MEETING\u0026#34;)))) 37 (org-todo-keyword-faces 38 (quote ((\u0026#34;TODO\u0026#34; :foreground \u0026#34;goldenrod1\u0026#34; :weight bold) 39\t(\u0026#34;NEXT\u0026#34; :foreground \u0026#34;DodgerBlue1\u0026#34; :weight bold) 40\t(\u0026#34;DONE\u0026#34; :foreground \u0026#34;SpringGreen2\u0026#34; :weight bold) 41\t(\u0026#34;WAITING\u0026#34; :foreground \u0026#34;LightSalmon1\u0026#34; :weight bold) 42\t(\u0026#34;CANCELLED\u0026#34; :foreground \u0026#34;LavenderBlush4\u0026#34; :weight bold) 43\t(\u0026#34;MEETING\u0026#34; :foreground \u0026#34;IndianRed1\u0026#34; :weight bold)))) 44 (org-todo-state-tags-triggers 45 (quote ((\u0026#34;CANCELLED\u0026#34; (\u0026#34;CANCELLED\u0026#34; . t)) 46\t(\u0026#34;WAITING\u0026#34; (\u0026#34;WAITING\u0026#34; . t)) 47\t(done (\u0026#34;WAITING\u0026#34;)) 48\t(\u0026#34;TODO\u0026#34; (\u0026#34;WAITING\u0026#34;) (\u0026#34;CANCELLED\u0026#34;)) 49\t(\u0026#34;NEXT\u0026#34; (\u0026#34;WAITING\u0026#34;) (\u0026#34;CANCELLED\u0026#34;)) 50\t(\u0026#34;DONE\u0026#34; (\u0026#34;WAITING\u0026#34;) (\u0026#34;CANCELLED\u0026#34;))))) 51 (org-adapt-indentation t) 52 (org-agenda-files pv/org-agenda-files) 53 ;; Do not dim blocked tasks 54 (org-agenda-dim-blocked-tasks nil) 55 ;; compact the block agenda view 56 (org-agenda-compact-blocks t) 57 (org-agenda-span 7) 58 (org-agenda-start-day \u0026#34;-2d\u0026#34;) 59 (org-agenda-start-on-weekday nil) 60 (org-agenda-tags-column -86) ; default value auto has issues 61 ;; Custom agenda command definitions 62 (org-agenda-custom-commands 63 (quote ((\u0026#34;d\u0026#34; \u0026#34;Daily agenda and all TODOs\u0026#34; 64\t((tags \u0026#34;PRIORITY=\\\u0026#34;A\\\u0026#34;\u0026#34; 65 ((org-agenda-skip-function \u0026#39;(org-agenda-skip-entry-if \u0026#39;todo \u0026#39;done)) 66\t(org-agenda-overriding-header \u0026#34;High-priority unfinished tasks:\u0026#34;))) 67\t(agenda \u0026#34;\u0026#34; ((org-agenda-ndays 1))) 68\t(alltodo \u0026#34;\u0026#34; 69\t((org-agenda-skip-function \u0026#39;(or (pv/org-skip-subtree-if-habit) 70\t(pv/org-skip-subtree-if-priority ?A) 71\t(org-agenda-skip-if nil \u0026#39;(scheduled deadline)))) 72 (org-agenda-overriding-header \u0026#34;ALL normal priority tasks:\u0026#34;)))) 73\t((org-agenda-compact-blocks t))) 74\t(\u0026#34;p\u0026#34; \u0026#34;Projects\u0026#34; 75\t((agenda \u0026#34;\u0026#34; nil) 76 (tags \u0026#34;REFILE\u0026#34; 77\t((org-agenda-overriding-header \u0026#34;Tasks to Refile\u0026#34;) 78\t(org-tags-match-list-sublevels nil))) 79 (tags-todo \u0026#34;-CANCELLED/!\u0026#34; 80\t((org-agenda-overriding-header \u0026#34;Stuck Projects\u0026#34;) 81 (org-agenda-skip-function \u0026#39;bh/skip-non-stuck-projects) 82 (org-agenda-sorting-strategy 83 \u0026#39;(category-keep)))) 84 (tags-todo \u0026#34;-CANCELLED/!NEXT\u0026#34; 85\t((org-agenda-overriding-header (concat \u0026#34;Project Next Tasks\u0026#34; 86\t(if bh/hide-scheduled-and-waiting-next-tasks 87\t\u0026#34;\u0026#34; 88 \u0026#34; (including WAITING and SCHEDULED tasks)\u0026#34;))) 89 (org-agenda-skip-function \u0026#39;bh/skip-projects-and-habits-and-single-tasks) 90 (org-tags-match-list-sublevels t) 91 (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks) 92 (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks) 93 (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks) 94 (org-agenda-sorting-strategy 95 \u0026#39;(todo-state-down effort-up category-keep)))) 96 (tags \u0026#34;-REFILE/\u0026#34; 97\t((org-agenda-overriding-header \u0026#34;Tasks to Archive\u0026#34;) 98\t(org-agenda-skip-function \u0026#39;bh/skip-non-archivable-tasks) 99\t(org-tags-match-list-sublevels nil)))) 100\tnil)))) 101 :bind 102 ((\u0026#34;C-c a\u0026#34; . \u0026#39;org-agenda) 103 :map org-mode-map 104 (\u0026#34;C-c C-q\u0026#34; . counsel-org-tag))) 值得一提的是，对一个 TODO 可以用 org-deadline 来指定 deadline，用 org-schedule 规划时间。例如：\n* TODO 学习 Emacs DEADLINE: \u0026lt;2023-05-20 Sat\u0026gt; 其中在日历中选择日期时，需要按 Shift+方向键。对于重复性任务如每周例会，则手动加上 \u0026quot;+7d\u0026quot; 表示每 7 天一个周期，具体参见文档：\n* MEETING 例会 SCHEDULED: \u0026lt;2023-05-25 Thu 18:30 +7d\u0026gt; 快速添加任务 但毕竟手动组织 agenda.org 也需要一定的思考，如果手头正在忙一些事情，但忽然来了个任务，不想被打断，就可以先快速把任务记下来，回头再整理。这个功能叫 org-capture，可将如下配置合并到上面的配置中：\n1;; ... 2(setq pv/org-refile-file (concat org-directory \u0026#34;refile.org\u0026#34;)) 3 4(use-package org 5 :custom 6 ;; ... 7 (org-capture-templates 8 (quote ((\u0026#34;t\u0026#34; \u0026#34;todo\u0026#34; entry (file pv/org-refile-file) 9\t\u0026#34;* TODO %?\\n%U\\n%a\\n\u0026#34; :clock-in t :clock-resume t) 10\t(\u0026#34;r\u0026#34; \u0026#34;respond\u0026#34; entry (file pv/org-refile-file) 11\t\u0026#34;* NEXT Respond to %:from on %:subject\\nSCHEDULED: %t\\n%U\\n%a\\n\u0026#34; :clock-in t :clock-resume t :immediate-finish t) 12\t(\u0026#34;n\u0026#34; \u0026#34;note\u0026#34; entry (file pv/org-refile-file) 13\t\u0026#34;* %? :NOTE:\\n%U\\n%a\\n\u0026#34; :clock-in t :clock-resume t) 14\t(\u0026#34;w\u0026#34; \u0026#34;org-protocol\u0026#34; entry (file pv/org-refile-file) 15\t\u0026#34;* TODO Review %c\\n%U\\n\u0026#34; :immediate-finish t) 16\t(\u0026#34;m\u0026#34; \u0026#34;Meeting\u0026#34; entry (file pv/org-refile-file) 17\t\u0026#34;* MEETING with %? :MEETING:\\n%U\u0026#34; :clock-in t :clock-resume t)))) 18 (org-refile-targets (quote ((nil :maxlevel . 9) 19 (org-agenda-files :maxlevel . 9)))) 20 ;; Use full outline paths for refile targets - we file directly with IDO 21 (org-refile-use-outline-path \u0026#39;file) 22 ;; Allow refile to create parent tasks with confirmation 23 (org-refile-allow-creating-parent-nodes (quote confirm)) 24 (org-cite-global-bibliography pv/org-bibtex-files) 25 :bind 26 ;; ... 27 ((\u0026#34;C-c a\u0026#34; . \u0026#39;org-agenda) 28 (\u0026#34;C-c c\u0026#34; . \u0026#39;org-capture) 29 :map org-mode-map 30 (\u0026#34;C-c C-q\u0026#34; . counsel-org-tag))) 当我们使用 C-c c 调用 org-capture 时，会提示我们想要添加的是什么任务。按 C-c C-c 保存到 ~/org/refile.org 中，也就是临时存储。等有空时，我们可以打开 ~/org/refile.org 文件，对着一个任务输入 C-c C-w 调用 org-refile，此时会提示你希望把这个任务插入到哪个文件的哪个项目的位置里。\n论文笔记 结合以上工具，org-mode 可以对论文进行笔记并关联 BibTeX。主要配置就是要告知 Emacs 我们的 BibTeX 文件在哪里，并设定一个存放论文 PDF 的仓库。这里，笔者配置了 ~/org/References 为仓库，~/org/References/reference.bib 为一个总的 BibTeX。二者都是列表，笔者可以根据需要设置多个仓库和多个 BibTeX 文件。笔者还使用了 org-ref 插件辅助管理。\n1;; ... 2(setq pv/org-bibtex-library `(,(concat org-directory \u0026#34;References/\u0026#34;))) 3(setq pv/org-bibtex-files `(,(concat org-directory \u0026#34;References/references.bib\u0026#34;))) 4 5(use-package org 6 :custom 7 ;; ... 8 (org-cite-global-bibliography pv/org-bibtex-files)) 9 10(use-package bibtex-completion 11 :custom 12 (bibtex-completion-pdf-open-function 13 (lambda (fpath) 14\t(call-process \u0026#34;open\u0026#34; nil 0 nil fpath))) ; 配置打开 PDF 的方式 15 (bibtex-completion-bibliography pv/org-bibtex-files) 16 (bibtex-completion-library-path pv/org-bibtex-library)) 17 18(use-package org-ref 19 :ensure t) 笔者的使用方式是这样的：\n创建一个总的论文列表（或是一类论文的列表），使用 C-c n f 调用 org-roam-node-find 命令新建一个名为 papers 的笔记节点。 获取论文的 BibTeX（可通过官网或 Google Scholar 等获得，也可手写），以这篇论文为例，获取它的 BibTeX 并粘贴到 ~/org/References/references.bib 中（花括号内的第一个字段是这个论文的 ID 标识，笔者习惯用 Google Scholar 的方式“作者+发表年份+标题第一个单词”来命名）： @inproceedings {li2023more, author = {Qiang Li and Qiao Xiang and Yuxin Wang and Haohao Song and Ridi Wen and Wenhui Yao and Yuanyuan Dong and Shuqi Zhao and Shuo Huang and Zhaosheng Zhu and Huayong Wang and Shanyang Liu and Lulu Chen and Zhiwu Wu and Haonan Qiu and Derui Liu and Gexiao Tian and Chao Han and Shaozong Liu and Yaohui Wu and Zicheng Luo and Yuchao Shao and Junping Wu and Zheng Cao and Zhongjie Wu and Jiaji Zhu and Jinbo Wu and Jiwu Shu and Jiesheng Wu}, title = {More Than Capacity: Performance-oriented Evolution of Pangu in Alibaba}, booktitle = {21st USENIX Conference on File and Storage Technologies (FAST 23)}, year = {2023}, isbn = {978-1-939133-32-8}, address = {Santa Clara, CA}, pages = {331--346}, url = {https://www.usenix.org/conference/fast23/presentation/li-qiang-deployed}, publisher = {USENIX Association}, month = feb, } 此时我们的剪贴板中应该刚好是这段 BibTeX（如果不是，就复制一下这段 BibTeX）。回到 papers 笔记文件中，输入 M-x org-bibtex-yank 命令，org-mode 就会为我们把这段 BibTeX 解析好放入我们的笔记中。实际上 org-mode 会把这些属性都折叠起来，所以比这里的显示要美观很多。 * More Than Capacity: Performance-oriented Evolution of Pangu in Alibaba :PROPERTIES: :TITLE: More Than Capacity: Performance-oriented Evolution of Pangu in Alibaba :BTYPE: inproceedings :CUSTOM_ID: li2023more :AUTHOR: Qiang Li and Qiao Xiang and Yuxin Wang and Haohao Song and Ridi Wen and Wenhui Yao and Yuanyuan Dong and Shuqi Zhao and Shuo Huang and Zhaosheng Zhu and Huayong Wang and Shanyang Liu and Lulu Chen and Zhiwu Wu and Haonan Qiu and Derui Liu and Gexiao Tian and Chao Han and Shaozong Liu and Yaohui Wu and Zicheng Luo and Yuchao Shao and Junping Wu and Zheng Cao and Zhongjie Wu and Jiaji Zhu and Jinbo Wu and Jiwu Shu and Jiesheng Wu :BOOKTITLE: 21st USENIX Conference on File and Storage Technologies (FAST 23) :YEAR: 2023 :ISBN: 978-1-939133-32-8 :ADDRESS: Santa Clara, CA :PAGES: 331--346 :URL: https://www.usenix.org/conference/fast23/presentation/li-qiang-deployed :PUBLISHER: USENIX Association :MONTH: feb :END: 利用 org-ref 绑定论文 PDF。在这个论文的下面输入 cite:li2023more，即 “cite:” 和这篇论文的 ID。org-ref 会自动识别到我们想要关联这个 BibTeX。随后我们可以单击这行字，或按 C-c C-o 调用 org-open-at-point。org-ref 会为我们弹出一个选择窗口，我们可以按 a 选择\u0026quot;add pdf to library\u0026quot;，输入下载好的论文的 PDF 路径。org-ref 会将该 PDF 复制到我们设定的仓库中，即 ~/org/References/ 中，并命名为 li2023more.pdf。 当我们想要阅读这篇论文时，对着刚刚的 cite:li2023more 按 C-c C-o，按 p 即可打开该 PDF。这里笔者配置的打开 PDF 的方式是用 Unix 系统的 open 命令打开，即用系统默认 PDF 阅读器打开。如果去掉该行配置，就会用 Emacs 打开。 笔记可以直接写在 papers 的这篇论文词条下面，如果笔记很长，也可以利用 org-roam 新建一个文件并链接到这里即可。 org-ref 还提供了多种方式导入论文，例如拖入 PDF、拖入网页 URL 等。但笔者使用中发现这些方式不是很稳定，不是百分之百好用，而上面介绍的步骤是一定有效的。此外，使用 org-mode 进行论文笔记和 Zotero、Mendeley 等文献管理软件并不冲突，完全可以组合使用。\n管理论文其实有很多种方式，例如 citar, org-roam-bibtex 等，读者可以根据需要自行探索。 ","link":"https://pavinberg.github.io/emacs-book/zh/orgmode/","section":"","title":"笔记系统 org-mode"},{"body":"赞赏本篇教程 ","link":"https://pavinberg.github.io/emacs-book/zh/donate/","section":"donate","title":""},{"body":"","link":"https://pavinberg.github.io/emacs-book/zh/categories/","section":"categories","title":"Categories"},{"body":"","link":"https://pavinberg.github.io/emacs-book/zh/tags/","section":"tags","title":"Tags"}]