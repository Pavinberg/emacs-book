[{"body":"为什么学习 Emacs Emacs 是一个文本编辑器系列，包含有多个分支，其中最主流的一支是 GNU Emacs，大多数情况下所说的 Emacs 都是指 GNU Emacs，本教程也使用 Emacs 指代 GNU Emacs。Emacs 这一名字最早来源于 “Editor MACroS”，后来也有人称它集合了五个主要功能键的首字母 Esc、Meta、Alt、Ctrl、Shift。\nEmacs 与 Vi 共同被称为最古老的 Unix 编辑器，一代代程序员对 Emacs 和 Vi （尤其后来出现的 Vim）产生了无休止的争论。Emacs 诞生已有近五十年时间，是世界上最古老而依然活跃（截止 2021 年）的开源软件之一。\nEmacs 的主要思路是大量依赖组合快捷键实现高效编辑，这直接导致了想要流畅使用 Emacs 必须要记忆 Emacs 的大量快捷键，需要相当一段时间熟悉。此外，Emacs 编辑器本身所使用的编程语言是 Emacs Lisp 语言，Lisp 语言的方言之一。Lisp 语言是诞生于 1958 年的世上第二古老高级程序设计语言，其语言以“列表”（List）作为语法和核心数据结构，由于其具备强大的宏系统，可以创造各式方言，Emacs Lisp 就是其中之一。这个语言相对于我们常见的编程语言来说，晦涩难懂，同样增加了 Emacs 的学习难度。网上流传着一个有趣的形容各个编辑器学习曲线的图片：\n那么，既然如此，为什么要学习这个难以学习的编辑器呢？就为了高效+全面+高度定制化。\n高效：Emacs 将快捷键使用到极致，凡事都尽可能使用快捷键来解决。这样一来，程序员需要记忆繁多的快捷键，但一旦形成了肌肉记忆，将能得到极高的效率。笔者根据自己的体验，在熟练使用 Emacs 的快捷键后，使用任何常规编辑器都会觉得效率低下。即使是使用如 Visual Studio Code 或 JetBrains IDE 系列辅以 Emacs 键位，由于其功能不全，体验也很差。 全面：除了基本的编辑功能，可以与其它各种工具相结合，完成编译、调试、版本管理等各类开发任务，可以说如果你想，可以将它打造为一个功能强大的 IDE。 可扩展与定制化：网络上有着非常大量的 Emacs 插件可供自由搭配选择，你很难想到一个需求是别人没有解决过的，更有大量的功能是你不接触 Emacs 可能永远想不到的。你可以根据你的需求安装插件，而不必安装你不需要的功能，最终你的 Emacs 会是为你自己高度定制化的一个编辑器。Emacs 插件涉及的功能非常广泛，一种调侃 Emacs 的说法是，Emacs 不是一个编辑器，而是一个操作系统，其中甚至有一些游戏、还能让 Emacs 成为一个功能完整的浏览器。下图是一个 xkcd 网站上的漫画 Real Programmers，调侃了 Emacs 可以让蝴蝶扇动翅膀，利用蝴蝶效应引发内存上的一个比特翻转，由此来进行编程，表现了 Emacs 功能的丰富。此外，你可以使用 Emacs Lisp 进行编程，实现你独特的需求。 特别的，在 Linux/macOS 系统的终端中，是可以使用部分 Emacs 快捷键的；在 macOS 系统中的各种文本编辑框，如备忘录、浏览器搜索框等等也都支持 Emacs 光标移动快捷键。因此可以说，掌握 Emacs 快捷键，在各种操作系统中都可以享受到其带来的方便快捷。\nEmacs 的主要相关资料 Emacs 主页：可在此下载安装包，还有文档、Wiki 等的入口。\nEmacs 官方文档：最准确、最全面。有能力可以直接按照官方文档进行学习。\nEmacs Wiki：关于 Emacs 插件、Emacs Lisp 的一些使用方法。\nEmacs Lisp 教程：Emacs Lisp 的完整教程。\nEmacs StackExchange 问答论坛：Emacs 的 StackExchange，有着大量关于 Emacs 的提问和精品回答。\nEmacs Reference Card：即 Emacs 备忘表（Cheatsheet）。前两个 PDF 是基本内容，基本操作卡片和“生存卡片”。\n对 Vim 用户 Emacs 有一个 evil 插件可以在 Emacs 中直接使用 Vim 的快捷键，这对 Vim 转 Emacs 用户而言非常友好，降低了转换成本。所以我们常能在社区看到许多 Vim 转 Emacs 的用户。此外，对于不想花过多时间配置的读者，可以使用下一小节中提到的 “Emacs 发行版”。\n其它 Emacs 本教程所讨论的 GNU Emacs 是最原始的 Emacs，需要从 0 开始配置。部分用户会觉得这样过于枯燥，于是有一些 “Emacs 发行版”，预装了很多插件。这样的 Emacs 有两个：Doom Emacs 和 Spacemacs，它们尤其对 Vim 转到 Emacs 的用户比较友好，因为它们预装了 evil 插件，可以在 Emacs 上使用 Vi 的操作。但本文只讲解原生 Emacs，也被称为 Vanilla Emacs。\n此外还有一个专门适配 macOS 的 Aquamacs，对 macOS 的一些特点进行了适配，例如用 Cmd+O 来替代 C-x C-f 打开文件。但笔者更偏爱 GNU Emacs，毕竟它在所有平台上的操作方式都是一致的。\n","link":"https://pavinberg.github.io/emacs-book/zh/intro/","section":"","title":"入门介绍"},{"body":"为什么要再写一篇 Emacs 入门教程，网上的资料不是很多吗？尽管社区中关于 Emacs 的资料看似非常丰富，但同时满足高质量和包括完整开发需要的资料并不常见。在中文社区中，很多教程时常有前半句没后半句，只告诉一件事怎么做而不教你一类事怎么做。或者\n本教程是面向中文社区的、旨在提供系统性学习流程的 Emacs 教程。大部分的 Emacs 教程，开篇就是教各种快捷键，让你练习如何移动光标、打开文件等等。虽然这样的开篇也没什么问题，但是这些教程时常没有下文——不完整；同时它不告诉你 Emacs 的运作逻辑、基本思想——不系统。\n因此本教程的相比于基础的操作细节，更侧重于讲述一些底层逻辑，包括少量 Emacs Lisp 编程知识，这样如果出了问题读者可以知道该去搜索什么关键词，哪里有可能找到答案。\n此外，本教程会尽可能涉及较广泛的配置，让初学者能够在一开始就知道有这样或那样的插件存在和配置方法，而避免受到一些浅薄的教程的误导。\n最后，为避免无意义的争论，在此说明：本文将会介绍 Emacs 的入门知识，并与此同时展示 Emacs 的一些优点。但本文无意与其它编辑器进行好坏对比，不涉及任何争论。\n你需要做到 本教程的读者总的来说，应当是喜爱钻研、富有耐心、对计算机学科较为热爱的人群。学习 Emacs 是一个漫长的过程，需要大量的练习和积累，需要耐心进行配置、解决出现的问题，这些就要求了读者应当是相关从业人员或爱好者，平日需要写许多的代码，并有一定的专业基础。这就是为什么本教程叫“专业”入门。\n尽管在一篇编辑器的教程中抬高学习门槛并不恰当，但笔者认为 Emacs 的学习难度较大，还是希望读者至少会一门编程语言的基础部分，并且在未来能保持一定的代码量，从而能不断训练使用 Emacs 的技巧。\n如果读者无法满足上述条件，笔者不建议学习 Emacs，还有很多其它编辑器可供选择。\n那么，现在我们开始吧!\n开始教程 ","link":"https://pavinberg.github.io/emacs-book/zh/","section":"","title":"专业 Emacs 入门"},{"body":"本篇介绍 GNU Emacs 的基础知识和操作。本文内容只是让读者初识 Emacs 操作，这些操作需要日积月累的练习才能掌握，本文的后半部分更偏向用于日后查阅；另一方面，很多操作有些繁琐难以记忆，笔者将会在后续介绍一些插件能够极大改善这些问题，因此读者如果遇到晦涩的地方不必过分担心，也不用死记硬背。\n文章的结尾附上了本文出现的快捷键及其命令名，供读者查阅。\n另外不要忘了官网的 Emacs Reference Card：即 Emacs 备忘表（Cheatsheet）。前两个 PDF 是基本内容，一个是基本操作卡片，另一个是更为简洁的“生存卡片”。可以打印出来放在一边。\n安装 截止本文书写日期（2021.8.24）Emacs 的稳定版本为 27.2。建议使用新一些的版本，最好是 Emacs 27 或 Emacs 26，因为一些插件需要 Emacs 更高版本的支持。\n更新（2022.4.6）： Emacs 28.1 正式发布，新增使用 GCC JIT 对 Emacs Lisp 字节码的执行进行加速，可以显著提高 Emacs 的运行速度。推荐大家安装 Emacs 28。 图形界面在官网下载安装包进行安装。\n此外还可以用正常包管理工具来进行安装。\nmacOS:\n1$ brew install emacs Debian/Ubuntu:\n1$ sudo apt-get install emacs 稍老一些的 Ubuntu 可能不能直接这样安装最新版本的 Emacs，需要自行去下载最新版本安装包安装。\n其它系统类似，安装操作网上资源较多，在此不做赘述。\n启动 图形界面可以直接打开程序。命令行输入命令启动 Emacs。\n1$ emacs 如果想要打开非图形界面版的 Emacs，输入：\n1$ emacs -nw # no window system 如果后面接文件名，则可以直接打开相应文件。\n启动后可以看到这样的界面，可以看到其中有一个 \u0026quot;Emacs tutorial\u0026quot;，如果读者英文不错，可以直接点击进入，进行互动入门教程，跳过本篇教程。\n对于 macOS，如果是用安装包手动安装的，直接输入 emacs 命令无法启动图形界面程序，也可以在命令行里添加一个 alias：\n1alias emacsx=\u0026#34;open -a /Applications/Emacs.app/ $1\u0026#34; 之后就可以用 emacsx 命令启动图形界面了。当然，读者可以换成更短的名字，比如 emx。但其实还是推荐用 Homebrew Cask 来安装。\n退出程序的方法请见最后的附录。\n关于键盘操作 为什么大量使用快捷键？\nEmacs 作为一个在图形界面诞生之前就存在的编辑器，其打设计之初就根本不需要鼠标来进行操作，那么直到今天，真正流畅的编程其实也最好不要引入过多的鼠标操作，越是常用的操作就应当更多地使用键盘而不是使用鼠标。鼠标是低效的，读者可以把手放到键盘上正常打字的位置，如果你现在忽然要使用鼠标来进行文本的选择，那右手（对于大部分人来说）就要立刻拿开，摸到鼠标、找到光标、移动到合适的位置、微调鼠标定位、选中、手放回原位。这么长的操作只是为了选中那么一点文字，而这又是如此常见的需求，这种操作模式会打断码代码的手部连贯性和头脑思绪的连贯性。\n快捷键的出现就是用来弥补这一不足，通过简短的按键来完成一些复杂的任务。而 Emacs 一不做二不休，直接将快捷键用到极致——所有操作都最好用快捷键。这样一来，程序员会比较辛苦，需要记忆繁多的快捷键，但一旦形成了肌肉记忆，将能得到极高的效率。\n需要提前说明的是，快捷键是一个十分自由的配置，你可以根据你自己的需要任意修改，笔者会给出一些笔者实践中的经验，但读者不必也不需要完全仿照，一切根据自己的习惯和需求来。\n功能键 Emacs 中有五个功能键： Control、 Meta、 Shift、 Super、 Hyper。其中部分名称读者可能不熟悉，那是几十年前的键盘上的按键名称，其中的 Hyper 键更是在现代键盘上消失了。那 Meta 和 Super 又是什么呢？ Meta 对应于普通 PC 键盘上的 Alt 键，Mac 电脑上的 Option 键。 Super 对应 PC 键盘上的 Win 键，对应 Mac 电脑上的 Command 键。那么我们知道， Super 键在现代系统中起到了重要作用，因此 Emacs 平常不使用和 Super 键相关的快捷键，Emacs 的绝大多数快捷键都是使用 Control 和 Meta 键，而其中一大部分都是只使用 Control 键。\n尽管 Hyper 键已经消失了，但是 Emacs 依然可以使用这个功能键，例如如果读者手上的键盘有一些不常用的按键，可以考虑设定为 Hyper 键，拓宽快捷键，这部分读者自行探索吧。 事实上 Emacs 中也有 Alt 键，但现在键盘上的 Alt 键都是被映射为 Meta，Alt 键也几乎不去使用了，为避免混淆就没有放到正文中介绍。 可以看到， Control 键是 Emacs 程序员键盘的“重灾区”，按 Control 键的小指也是 Emacs 程序员最易出问题的部位，因此笔者强烈建议，在你正式使用 Emacs 后改变键盘键位保护手指。 例如笔者将 Control 键改到了大小写锁定键上（读者可以调换两个键，但考虑到实际很少用大小写锁定键，笔者索性不要大小写锁定键了）。也可以将 PC 键盘上的 Win 键、Mac 键盘上 的 Command 键与 Control 调换，这样使用强壮的大拇指也没有问题。如果不想全局改变，也可以只在 Emacs 内部进行，后面会提到。 笔者作为 Mac 用户，推荐一款改键软件 Karabiner-Elements，它甚至可以将 Emacs 常用键位完全拓展到全局。 在 Emacs 中，我们经常需要自定义快捷键，那么需要一种方式来表示快捷键，这样才能写到配置文件里。Emacs 使用一个单独的字母表达功能键，见下表。\nEmacs 功能键 缩写 对应键盘按键(PC/Mac) Control C Ctrl / Control Meta M Alt / Option Shift S Shift / Shift Super s Win / Command Hyper H 无 Emacs 用连字符表示“同时按下”。例如，我们用 C-a 表达“先按下 Control 键不要松，再按下 a 键“。 C-x b 则表达“先按下 Control 键不松，按下 x 键，松开这两个键，按下 b 键”。\nC-S-\u0026lt;mouse-1\u0026gt; 表达“同时按下 Control 键和 Shift 键，然后鼠标左键点击“。这里提到了鼠标是因为 Emacs 图形界面支持鼠标操作，并且在有些场景下的确使用鼠标更为方便（例如无规律的多光标选择）。\n特别的， Meta 键做前缀有两种按法，例如 M-x 可以“按住 Meta 键不要松，再按下 x 键“，也可以“先按一下 Esc 键松开，再按一下 x 键“。后者是为了在应对无法使用 Meta 键的硬件或系统，但实际操作有很多不便。因此读者尽可能使用 Alt / Option 作为 Meta 键来按。\n一些终端例如 Mac 自带的终端默认不会把 Option 键作为 Meta 传入，但只需打开它的偏好设置，其中 ”Profiles - Keyboard“ 中有一项“将 Option 用作 Meta 键“，勾选即可。iTerm2 同理。 Emacs 命令 在介绍具体的快捷键之前，要先说明 Emacs 的主体逻辑。与其它编辑器类似，Emacs 也是通过命令进行交互的。而所谓命令，就是 Emacs 中使用 Elisp 语言定义的一些函数。这些函数可以完成一些功能。例如，即使是最最简单的“将光标上移一行”，也对应着命令 previouse-line 。一切操作都对应一个命令，而快捷键的本质是在调用这些命令。\n对 Emacs 输入命令需要先按下 M-x，此时你会看到 Emacs 最下面的空行上出现了 \u0026quot;M-x \u0026quot;，然后等待你的输入，随后你便可以输入一个函数名。这一快捷键可以说是最重要的一个快捷键了，只要有它，即使你忘记了其它快捷键，也可以输入函数名进行调用。\n命令名的传统是有连字符连接的多个有意义的英文单词。在输入时可以用空格代替连字符。也可以使用 \u0026lt;tab\u0026gt; 键自动补全。\n自然， M-x 也对应着命令 execute-extended-command。 基础快捷键 接下来介绍一些入门基础内容。读者最好打开一个文本进行尝试，例如前面提到的 Emacs 内置教程，如果不知如何打开，请按下 C-h t （注意松开 Control 键和 h 键之后再按 t 键）。或者读者打开任意一段代码。\n对于 Vim 用户，可以安装 evil 插件来使用 Vim 按键，可略读下文的大部分内容。 插件的安装方式请参考基本配置和插件：功能增强类的最后一节。 如何退出 退出程序： C-x C-c。\n对于输了一半的命令，或者按了一部分快捷键但不想继续了，可以按下 C-g 放弃。此外在任何场合如果出现了卡住等情况，也都可以尝试输入 C-g 打断。\n光标移动 光标移动也需要教？是的，Emacs 快捷键甚至连方向键都绑定了快捷键。如此大费周章是由于方向键在键盘上处于非常偏的位置，按方向键时你的右手需要做移动，而按方向键又是常见操作，Emacs 认为这种程度的手部移动就已经在打断写代码的连贯性了！\n于是，方向键上下左右的快捷键是 C-p、 C-n、 C-b、 C-f。它们的英文含义分别是：previous（前）、next（后）、back（退）、forward（进）。一开始看的确很奇怪，但熟练之后确实方便顺手。\n除此之外，Emacs 提供了多种方式进行光标移动：\n以词为单位： M-b 光标向左移动一个词， M-f 光标向右移动一个词。 首尾： 行： C-a 光标移至行首， C-e 光标移至行尾。而代码经常是有缩进的，但 C-a 会直接移动到整个行首，并不能直接编辑开头的文字，这种情况可使用 M-m 来移动到文字的开头。不过这里只是介绍，笔者之后会直接推荐一个插件 mwim，避免这个琐碎的小区别。 句子： M-a 光标移至句首， M-e 光标移至句尾。 整个文件： M-\u0026lt; 移动到文件开头， M-\u0026gt; 移动到文件末尾。注意这里需要同时按下 Meta 键、 Shift 键和逗号/句号键。 窗口：M-r 按第一次——光标移动到窗口中间行；接着按第二次——光标移动到窗口最上面一行；接着按第三次——光标移动到窗口最下面一行。 笔者平日使用 mac 电脑，macOS 本身就有着近乎全局的这套 Emacs 快捷键，因此笔者平日很少按方向键，全部使用这四个快捷键。读者需要大量练习，形成肌肉记忆。\n如果想增加一些趣味性，可以玩 Emacs 内的贪吃蛇游戏来锻炼对方向键的熟练度。按 M-` 调用 tmm-menubar，按 t 选择 Tools，按 g 选择 Games，按 s 选择 Snake，然后开始游戏吧！ 编辑操作 删除字符：删除一个字符与正常一样，按下删除键（在 Emacs 中删除键写为 \u0026lt;DEL\u0026gt; ）即可删掉光标左侧的字符。如果想要删掉右侧的字符，就按下 C-d 键。 移除词：M-d 移除光标右边一整个词。M-\u0026lt;DEL\u0026gt; 移除光标左侧一整个词。 移除右侧直到句子结尾： M-k。 移除右侧直到行结尾： C-k 。 选中部分区域（region）：把光标移动到某处，按下 C-SPC （ SPC 表示空格键，space），此时 Emacs 最下方的空行显示 “Mark set“，表示当前打了一个标；接着任意移动光标到另一个位置，可以看到半透明的选择框。这就是和平日里你使用鼠标进行选择是一样的。 复制： M-w 复制选中的区域。 移除： C-w 移除选中的区域。 注意，这里我用了“删除”和“移除“两种说法，”删除“对应于 \u0026quot;delete\u0026quot;，是真的删除，而“移除”对应于 \u0026quot;kill\u0026quot;，相当于“剪切”，之后可以再次插入到其它位置，即 \u0026quot;insert\u0026quot;，相当于粘贴。\n笔者的实际使用中，复制比移除更为常见，由于光标的移动等大量操作依赖于 Control 键，因此将复制与移除调换，使用 C-w 做复制，M-w 做移除更为顺手。读者可以根据自己的需要更改，具体配置方法见后续教程。 Emacs 内部维护了一个环形“剪贴板历史”，当你想插入之前移除的内容时（即粘贴之前剪切的内容），按下 C-y，这被称为 \u0026quot;yank\u0026quot;，它会将最近一次移除的内容插入回来。那么如何粘贴历史记录呢？在一次 \u0026quot;yank\u0026quot; 的基础上，再按 M-y ，就可以得到倒数第二次移除的内容，再按一次 M-y 即可得到倒数第三次移除的内容，以此类推。后面笔者会介绍插件 counsel 辅助这个过程。\n撤销（undo）： C-/ 或 C-_ 或 C-x u。撤销刚刚的操作。对字符进行编辑例外，例如你按了 5 次删除键删除了 5 个字符，按一下撤销即可复原。 重做（redo）：Emacs 对于历史记录也维护成了一个环。但 Emacs 并没有直接的重做操作，而是先按一下 C-g ，即没有操作，此时再按撤销键时，会撤销上次的“撤销”，相当于重做；也可以理解为按下 C-g 后这个环的移动方向会改变。所以 Emacs 其实不分 undo 和 redo，而是靠改变历史记录的移动方向来控制。那么读者一定觉得这里难以理解不便使用，没错，因此笔者将会在后面介绍更好用的插件 undo-tree。 标记与跳转 上文提到的选中键 C-SPC 不仅是选中文本这么简单的功能，它的本质是设定一个标记（mark）。Emacs 还有一个标记跳转功能，例如我们先在文本的第一行，按下两次 C-SPC（这样我们即打了标记，又没有选中文本），然后光标移动到别的位置（甚至以后学过之后，到别的文件），这时候按下 C-x C-SPC 或 C-u C-SPC，即可立刻跳转回刚刚的位置。同样的，有更好用的插件可以辅助这一功能即上文提到的 counsel。\n想要跳到特定的行，M-g M-g 加行号、回车即可 。\n重复操作 Emacs 提供了一个机制可以把一个命令重复执行任意次数。具体来说，先按下 C-u，再按数字表示次数，再按下命令的快捷键。例如：C-u 12 C-n 表示向下 12 行。如果不加数字，默认是 4 次。\n注意，有些特殊命令不表示次数，例如与 M-x 组合时表示传参。读者暂不需要知晓这么深刻。 页面移动 C-v 会向下翻滚一页内容， M-v 会向上翻滚一页。但 Emacs 会保留三行不会被翻过去，这样看起来更为舒服。\nC-l 第一次按时，会移动页面使得光标所在行在窗口中央。这样当我们写文本写到下面时，只需要按一下 C-l 即可把当前光标所在行移动到正中央，有利于查看。但如果按完一次之后紧接着再按一次 C-l，会移动页面使得光标所在行在窗口最上面，而按第三次 C-l 会移动页面使得光标所在行在窗口最下面。第四次按与按一次的效果相同，如此循环。\n搜索文本 从光标位置向下搜索，按下 C-s，即 search，此时最下方空行会出现 \u0026quot;I-search: \u0026quot;，输入你要搜索 的文本，此时会显示出能够匹配的文本，光标会移动到第一个匹配的文本位置。\n如果你想让光标跳到下一个匹配位置，就再按一次 C-s。 如果想停留在当前位置，退出搜索，按下回车键。 如果想放弃搜索，回到搜索前的位置，按下 C-g。 从光标位置向前搜索，按下 C-r，其用法与 C-s 一致，只是方向相反。安装了 swiper 的话会显示搜索结果列表，更为直观（swiper 和上文提到的 counsel 是一套插件）。\n其它小操作 交换光标左右的字符：C-t ；交换光标前后的词：M-t；交换光标所在行和上一行：C-x C-t。还有交换句子、段落、选择区域等，但没有快捷键，详见文档。 在光标所在行下方创建一个新的空行：C-o；将光标所在前后所有连续空行变为一个空行：C-x C-o。 将光标后一词变为小写：M-l；变为大写 ：M-u；变为首字母大写：M-c。\n获得帮助 Emacs 内置了多种获取帮助的方式。其共有前缀 C-h。\n简要描述快捷键功能：按下 C-h c 后，按想查询的快捷键。例如 C-h c C-p，会在最下面出现：\u0026quot;C-p runs the command previous-line\u0026quot;，告诉你 C-p 键对应的命令是 \u0026quot;previous-line\u0026quot;。 详细描述快捷键功能：按下 C-h k 后，按想查询的快捷键。 描述函数（function）： C-h f，输入函数名。 描述变量（variable）： C-h v，输入变量名。 列出含某一关键词的命令（Command Apropos）： C-h a，加一个关键词。 列出含某一关键词的符号的文档： C-h d，加一个关键词。 这些帮助太多了记不住？还有帮助的帮助：\nC-h ?，列出以上功能，以及其它帮助功能。\n有一个小插件 which-key 可以在敲快捷键给予一定的提示作用，后续会详细介绍。\n一些系统对有些键位会做映射。例如 macOS 就会将 C-/ 映射为 C-_ ， C-SPC 映射为 C-@。不影响日常使用，但是读者想覆盖键位时需要注意。 命令列表 操作描述 快捷键 命令名 输入命令 M-x execute-extended-command 退出程序 C-x C-c save-buffers-kill-terminal 放弃当前输入 C-g keyboard-quit 光标向上一行（方向键上） C-p previous-line 光标向下一行（方向键下） C-n next-line 光标向左一个字符（方向键左） C-b backward-char 光标向右一个字符（方向键右） C-f forward-char 光标向左移动一个词 M-b backward-word 光标向右移动一个词 M-f forward-word 光标移至行首 C-a move-beginning-of-line 光标移至行尾 C-e move-end-of-line 光标移动到一行缩进的开头 M-m back-to-indentation 光标移至句首 M-a backward-sentence 光标移至句尾 M-e forward-sentence 光标移至文件开头 M-\u0026lt; beginning-of-buffer 光标移至文件结尾 M-\u0026gt; end-of-buffer 光标移动至窗口的中间、最上、最下 M-r move-to-window-line-top-bottom 删除光标右侧字符 C-d delete-char 移除光标右侧词 M-d kill-word 移除光标左侧词 M- backward-kill-word 移除右侧直到句子结尾 M-k kill-sentence 移除右侧直到行尾 C-k kill-line 设置标记以选择区域 C-SPC set-mark-command 复制区域 M-w kill-region-save 移除区域 C-w kill-region 插入已移除文本 C-y yank 插入历史移除文本 M-y yank-pop 撤回 C-/ 或 C-_ 或 C-x u undo 跳转到上一标记 C-x C-SPC 或 C-u C-SPC pop-global-mark 跳转到行号 M-g M-g goto-line 重复 C-u universal-argument 向下一页 C-v scroll-up-command 向上一页 M-v scroll-down-command 移动页面使得光标在中央/最上方/最下方 C-l recenter-top-bottom 向后搜索 C-s isearch-forward 向前搜索 C-r isearch-backward 交换前后字符 C-t transpose-chars 交换前后词 M-t transpose-words 交换前后两行 C-x C-t transpose-lines 在下方新建一行 C-o open-line 删除连续空行为一个空行 C-x C-o delete-blank-lines 将后面的词变为小写 M-l downcase-word 将后面的词变为大写 M-u upcase-word 将后面的词变为首字母大写 M-c capitalize-word 放大字号 C-x C-= text-scale-adjust 缩小字号 C-x C-- text-scale-adjust 重置字号 C-x C-0 text-scale-adjust 简要描述快捷键功能 C-h c describe-key-briefly 描述快捷键功能 C-h k describe-key 描述函数功能 C-h f describe-function 描述变量 C-h v describe-variable 列出含某一关键词的命令 C-h a apropos-command 列出含某一关键词的符号的文档 C-h d apropos-documentation 帮助的帮助 C-h ? help-for-help ","link":"https://pavinberg.github.io/emacs-book/zh/basic/","section":"","title":"基础操作"},{"body":"本篇介绍 Emacs 的界面术语、如何管理多个文件，如何分割显示等等。同样的，本文更多介绍概念，具体操作起来是有插件可以方便我们进行操作的。结尾的附录包含了本文涉及的所有快捷键。\n初识界面 首先我们需要了解 Emacs 界面的一些术语。了解术语更多是为了在网上搜资料、看文档、配置时能够更准确地抓住关键。\nFrame：如果用图形界面打开 Emacs 程序，那么一整个程序窗口被称为 Frame，如果打开了多个窗口就有多个 Frame；如果在终端内打开 Emacs，那么 Emacs 所占据的整个终端的界面被称为 Frame。上图都是一个 Frame。\nMenu bar：即菜单栏，在 Frame 的最上方。默认包括了 File、Edit……等等下拉菜单。在终端中不能用鼠标时，需要用 menu-bar-open 命令打开，对应快捷键 \u0026lt;f10\u0026gt; 。此外还有一个 M-` 键（对应命令 tmm-menu）可以从下方展开互动界面打开菜单。\nTool bar：即工具栏。只在图形界面时可以使用，就是上面第二张图中那一些图标。由于它十分丑陋且功能又很基本，在上一篇教程中已完全涉及，所以正常笔者会关掉工具栏——在配置文件中加入代码 (tool-bar-mode -1) （如何编辑配置文件将在后续教程中详细介绍）。\nEcho Area：整个界面下方的一行就是“回显区”，用以打印各种简短的信息。例如上面第二张图就打印了如果你想获取帮助就按 C-h C-a，上一篇教程中也提及了这一命令。\nWindow：Tool bar 以下（如果有）、Echo area 以上这一整个区域，就是 Window，即窗口。 可以看到 Emacs 的窗口和我们日常使用电脑所说的窗口不是一个东西，一定要注意，不然在配置、调用命令或者在网上搜索信息时会搞错。我们日常称为窗口的在 Emacs 中被称为 Frame，而 Frame 内的核心区域才被称为 Window。\nMode line：Window 最下方灰色的一行即为“模式行”（即显示 -UUU:%%--F1 GNU Emacs 的部分）。这里会显示当前 Buffer 的一些信息（什么是 Buffer 见下文）大概包括了文件编码、是否修改、当前 Buffer 名、光标所在位置占全文百分比、行号（L1 表示第一行）等等。它的内容可以自定义，也可以使用 smart-mode-line 插件进行管理，后文将会更多介绍。\nScroll bar：图形界面时 Window 的最右侧有一滚动条。事实上在 Emacs 中根本不需要用滚动条，所以笔者也直接关闭了它，让界面更清爽，在配置中加入 (when (display-graphic-p) (toggle-scroll-bar -1)) 表示在是用图形界面时关闭滚动条。\nCursor：光标。光标是一个 1 字符宽的方块，但其真正表达的位置是其左侧的长边，即两字符之间。文档中有一些关于其显示效果的设置，例如可以换成大家日常更习惯的小竖线（bar），但其实笔者觉得还是方块（box）比较显眼，看习惯也挺好。\nPoint：光标所在的位置称为 Point。区别于光标的是，光标有且只有一个，但 Point 是针对 Buffer 的，每个 Buffer 都有一个 Point。许多命令的触发都要读取 Point 信息。\n文件与 Buffer 前面多次提到的 Buffer 到底是什么呢？接下来我们通过打开多个文件来展现 Buffer 的作用。\n打开多文件 之前我们是在命令行中使用 emacs \u0026lt;filename\u0026gt; 的方式来打开文件。而想要在 Emacs 内打开一个文件，按下 C-x C-f（ find-file ），此时 Echo area 会出现 “Find file: “，后面为一个路径，输入文件对应的路径即可打开相应文件。如果想新建文件，只需要输入一个不存在的文件名即可。输入时可以使用 键自动补全，就和 Linux 中类似。插件 ivy 或 helm 可以辅助这一过程，后面详细介绍。\n保存文件对应命令 C-x C-s。\n开文件并只读不改：C-x C-r。 打开另一相近文件：C-x C-v，此时下面的路径会自动以当前文件全名作为初始路径（而不是目录的路径），这样方便稍微修改一些文件名打开另一文件。 已打开的文件切换为只读模式：C-x C-q。 Emacs 可以打开多个文件，同样使用 C-x C-f 打开即可。 但是你如果打开了第二个文件，便会发现第一个文件就消失不见了，应当去哪里找呢？事实上，所有打开的文件都会被放入一个被称为 Buffer 的对象中，当打开了第二个文件时，第一个文件所在的 Buffer 会切入后台，而第二个文件的 Buffer 会占据当前的 Window。Buffer 的名字显示在 Mode line 中间，通常是文件名本身。\nEmacs 也可以用这个方式打开目录（文件夹），会显示出目录内的文件（此即 Linux 的设计理念，一切皆为文件，即使是目录也本质上是一个文件），可以用光标选择想打开的文件。\nBuffer 的切换 切换 Buffer 有三类方法，简短的方法是使用 C-x b，输入 Buffer 的名字后按回车即可切换。 Echo area 中会提示你，如果什么也不输直接按回车，可以跳转到当前默认的 Buffer 中，这样方便在两个文件中来回切换。\n显然这样如果 Buffer 多了会记不住名字也不便于管理，于是可以使用第二个方法，C-x C-b，此时会弹出一个 Window，名为 \u0026quot;Buffer List\u0026quot; ，列出了当前所打开的所有 Buffer。其中可以看到多个以星号（*） 开头结尾的 Buffer，那些都是 Emacs 用于输出一些信息的 Buffer，并不是由于打开文件而产生。例如 “Messages” 是 Emacs 的一些输出信息。“scratch” 是可以编写一些 Elisp 代码的地方。Buffer 开头如果是 %，表示这个 Buffer 被修改过而没有保存。\n如果当前光标没有在 \u0026quot;Buffer List\u0026quot; 中可以用 C-x o 键切换过去。 可以通过光标选择切换到某个 Buffer。同时在这个 \u0026quot;Buffer List\u0026quot; 中有很多功能可以使用。按问号（?）可以显示帮助。常见的操作例如 q 退出， d 标记一个 Buffer 打算关闭，s 标记一个 Buffer 打算保存，u 取消标记，x 执行刚刚标记过的删除和保存操作。事实上，在这里上下移动光标也不需要 C-p 和 C-n，直接按 p 和 n 即可。\n想要关闭当前的 Buffer？直接在当前的 Buffer 处按下 C-x k 即可。\n此外，第三种方法是使用 C-mouse-1 （mouse-1 表示鼠标左键）然后用鼠标菜单切换 Buffer 。\n事实上，在输入 M-x 后、C-x b 后在 Echo area 显示的等待输入的区域被称为 Minibuffer， 所以它们的输入方式是共通的，都可以用相同的补全机制等。 文件备份 使用 Emacs 打开文件后，会发现目录下会多一个和打开的文件同名但是后面多了个 ~ 字符的文件，例如打开了 names.txt 后会出现 names.txt~， 这是 Emacs 的备份机制，防止程序或系统崩溃，或是用户误操作破坏了文件。可以设置关闭或文件数量上限等等，详见文档。（关闭备份需要设置：(setq make-backup-files nil)）。\n多 Window 想要同时打开两个文件相互参照对比是一个再常见不过的需求了，Emacs 自然可以做到。\nC-x 2 ：上下分割出两个 Window。 C-x 3：左右分割出两个 Window。 C-x 0：关闭光标所在处的 Window。 C-x 1：只保留光标所在处的 Window，关闭其它 Window。其它 Window 的 Buffer 依然没有关闭，可以通过 \u0026quot;Buffer List\u0026quot; 查看。 C-x o：将光标切换到下一个 Window。 分割后，默认会把当前的 Buffer 也显示到新的 Window，即显示了两个一样的 Window。再次强调一下，Buffer 对应真正打开的文件，而 Window 是把 Buffer 显示出来的元件，所以一个文件只会开一个 Buffer，但可以有多个 Window 显示。于是，在新的 Window 里用 C-x C-f 打开另一个文件即可看到两个文件了，当然也可以正常用上面所说的 Buffer 切换。\n那么既然开一个新的窗口并打开新的文件这个需求很常见，对此如果只有以上快捷键，需要先 C-x 3 分割出一个窗口，C-x o 切换到新窗口，C-x C-f 打开新文件，过于繁琐。所以 Emacs 提供了一个快捷键：\nC-x 4 f 来达到“在另一个窗口打开新的文件，如果只有一个窗口就分割成两个”的效果。\n此外，还有 C-x 4 b 表示“在另一个窗口切换到另一 Buffer，如果只有一个窗口就分割成两个” 。C-x 4 d 表示 “在另一个窗口打开目录，如果只有一个窗口就分割成两个”。\n可以总结出 C-x 4 为前缀时，就表达“在另一个窗口做……“。\n在打开两个窗口时，如果我们光标在第一个窗口，而希望第二个窗口翻页，那么就可以用 C-M-v 向下翻页。用 C-M-S-v （同时按下 Control，Meta， Shift 和 v）向上翻页。\n那么如果在已经分割之后再分割呢？Emacs 会继续做二等分，变成 3 个、4 个等窗口。此时窗口的切换和关闭就没有那么方便了。插件 ace-window 可以辅助这一过程，后面详细介绍。\n多 Frame 既然能多 Window，自然能多个 Frame。打开一个新的 Frame 可以使用快捷键 C-x 5 2； 在一个新的 Frame 打开文件，可以使用快捷键 C-x 5 f。C-x 5 和 C-x 4 基本类似，只是前者在 Frame 间操作，后者在 Window 间操作。\n笔者的日常使用中，对多文件的打开更偏爱在单个 Frame 中用多个 Window，很少在多 Frame 中间频繁切换。\n模式（mode） Emacs 的核心要素之一就是模式（mode）。一个模式就对应着一组环境，不同模式可以分别进行配置，应对不同的场景。例如，编写 C++ 代码时就对应 c++-mode，编写 Python时使用 python-mode。在不同的语言的 mode 中，编译、执行的方式都是不同的，这样只要事先定义好 mode，就可以在使用过程中方便切换各种需求场景。\nEmacs mode 分两类，主模式（Major mode）和次模式（Minor mode）。\n主模式 主模式默认根据 Buffer 的文件类型来选择，一个 Buffer 只能对应一个主模式。例如，Emacs 发现你打开了 .cpp 为后缀的文件，就会把 Buffer 自动设置成 c++-mode，发现你打开了 .py 后缀的文件，就把相应 Buffer 自动设置为 python-mode，最直观的区别是 Emacs 为不同语言的源码提供了不同的语法高亮。 主模式的名字会显示在 Mode line 上。\n我们也可以手动切换主模式，只需要按下 M-x ，输入相应的模式名称即可。通常来说其实我们不需要手动设置。\n最基本的主模式是 Fundamental mode，就是没有进行任何配置的模式 。 次模式 同一个 Buffer 可以有多个次模式，次模式可以进一步调整、增加一些配置。通常来说，插件都是靠次模式来起作用的。当我们安装插件时，插件的官网会提示如何设置这个插件，其中大多都会使用次模式。\n官网中列出了一些常用次模式。下一篇教程的配置中，笔者会直接列出其中常用的几个是如何设置的。\nMode hook 每一个主模式都对应着一个 Mode hook，hook 是挂钩的意思，Mode hook 的作用就是当启动一个主模式时，自动执行一些已经“挂钩”到这个主模式的函数或次模式。由此，我们可以自由地向一个主模式上挂上各种功能，在启动这个主模式时就可以自动跟随着一起启动。\nMode hook 的名字通常就是“主模式名-hook”。例如，我们希望在主模式“文本文件模式” text-mode 时启动次模式“检查拼写” flyspell-mode ，我们就可以这样写配置：\n(add-hook 'text-mode-hook 'flyspell-mode) 这样当我们打开 txt 文件时，会自动开启检查拼写功能。\ntext-mode 是基于文本的文件的一个主模式，有一些其它主模式是由它派生，例如 html-mode。而相对的，还有编程模式 prog-mode，各种编程语言对应的主模式都是由它派生，包括我们上文提到的 c++-mode 和 python-mode。那么如果我们希望在任何编程语言时都有一些共同需要的功能，例如编程时我们希望有代码块折叠功能，就为 prog-mode-hook 挂上相应功能就好。\n1(add-hook \u0026#39;prog-mode-hook #\u0026#39;hs-minor-mode) 在下一篇教程中，我们会进一步讨论这些应该如何配置更好。\n总结 以上内容介绍了 Emacs 界面的术语，如何打开多个文件，如何在多个 Buffer 之间切换和如何使用多个 Window 和 Frame。希望读者多进行尝试，感受一下细节。如果熟练掌握到现在为止的内容，读者应当可以满足编辑文本方面的基本需求了。\n命令列表 操作描述 快捷键 命令名 下拉菜单栏 menu-bar-open 互动菜单栏 M-` tmm-menubar 打开文件 C-x C-f find-file 保存文件 C-x C-s save-buffer 打开并只读文件 C-x C-r find-file-read-only 打开另一相近文件 C-x C-v find-alternate-file 只读模式 C-x C-q read-only-mode 切换到 Buffer C-x b switch-to-buffer 列出 Buffer C-x C-b list-buffers 关闭 Buffer C-x k kill-buffer 鼠标列出 Buffer C-mouse-1 mouse-buffer-menu 上下分割出 Window C-x 2 split-window-below 左右分割出 Window C-x 3 split-window-right 关闭当前 Window C-x 0 delete-window 只保留当前 Window C-x 1 delete-other-windows 切换到另一 Window C-x o other-window 在另一 Window 中打开文件 C-x 4 f find-file-other-window 在另一 Window 中切换 Buffer C-x 4 b switch-to-buffer-other-window 在另一 Window 中打开目录 C-x 4 d dired-other-window 创建新的 Frame C-x 5 2 make-frame-command 在另一 Frame 中打开文件 C-x 5 f find-file-other-frame 让另一 Window 向下翻页 C-M-v scroll-other-window 让另一 Window 向上翻页 C-M-S-v scroll-other-window-down ","link":"https://pavinberg.github.io/emacs-book/zh/buffer/","section":"","title":"多文件与模式"},{"body":"本篇介绍配置 Emacs 相关的知识和操作。本文主要内容归纳：\n简单的 Emacs Lisp 语言知识——让你在配置时游刃有余 配置文件的知识——模块化的写法 一些观点——最好不要完全使用并依赖大牛的配置，把配置掌握在自己手中 一些基础配置——开启部分 Emacs 功能 介绍插件的安装并用 use-package 管理插件——管理成本低、逻辑更清晰 快捷键、变量的设置——迈出你的自定义脚步 Emacs Lisp 简介 为什么要了解 Emacs Lisp Emacs Lisp 是世界上第二古老高级编程语言 Lisp 专为 Emacs 打造的方言。官方提供了 Emacs Lisp 的入门介绍和参考手册。简单来说 Emacs Lisp 编程语言就是用来为 Emacs 编写逻辑，Emacs 的底层和绝大部分插件都是用这个语言写出来的。同时，作为用户，我们也可以使用 Emacs Lisp 编写一些自定义逻辑，甚至进一步形成插件。\n学习一门语言自然是比较麻烦的，但完全不必紧张，事实上绝大部分情况我们都不需要自己写 Emacs Lisp，基本上你想要的需求都可以在网上搜索到其他人已经写好的代码，至多只需要微调一下。为了应对这种需要微调的情况，同时也显得更加专业，加强对 Emacs 的掌控，我们简单了解一下 Emacs Lisp 的语法。\n当然读者如果确实不想在这件事上耗费时间精力，可以跳到下一节直接了解“配置文件”。\n语法简介 以下语法介绍为了便于理解存在一些简化和不是百分百准确的类比。最终以文档为准。\nEmacs Lisp 对于大部分人来说是十分陌生的，其语法看着就十分古怪。以下是一个例子（来源于 ivy 插件）：\n1(defun ivy-set-prompt (caller prompt-fn) 2 (setq ivy--prompts-list 3 (plist-put ivy--prompts-list caller prompt-fn))) Emacs Lisp 发源于 Lisp，而 Lisp 就是 “List Processing“ 的缩写，顾名思义，Lisp 语言的核心就是列表（List）。在 Lisp 中，每一对小括号表达了一个列表，列表元素用空格分隔。在执行 Lisp 时，会把列表的第一个元素作为函数名，后面的元素都是函数的参数。元素可以是一个“词”，也可以是另一个列表。可以类比 Shell 命令的写法，也是第一个词是命令名，而后面的是命令的参数。\n例如，2+3+4 在 Lisp 中写为：\n1(+ 2 3 4) 因为 + 就是个函数，后面是它的参数。 再如 4+(3-2) 写为：\n1(+ 4 (- 3 2)) 那么在 Emacs 中基本都是做一些定义函数、变量等操作的 ，定义函数就用 defun 关键字， 设置变量的值用 setq 关键字。\n所以上面展示的那段 Emacs Lisp 代码可以约等于如下 C 语言代码（类型名是笔者杜撰的）：\n1void ivy_set_prompt(CallerType caller, FnType prompt_fn) { 2 ivy__prompts_list = plist_put(ivy__prompts_list, caller, prompt_fn); 3} 约等于如下 Python 代码：\n1def ivy_set_prompt(caller, prompt_fn): 2 ivy__prompts_list = plist_put(ivy__prompts_list, caller, prompt_fn) 注意这里笔者把所有的连字符替换成了下划线。这里就可以看出，Lisp 的变量名、函数名要比 C/C++、Python、Java 等主流语言的变量名的要求更宽松，Lisp 的变量名可以包含许多字符，所以如果看到了一些奇奇怪怪的名字，不要感到惊讶，就是变量名。\n还有一些常见关键字如 let 为一组变量圈出一个作用域、if / when / unless 表示条件语句。 t 表示 true，nil 表示空（相当于 C 语言的 NULL、Python 的 None）。\n另外有一些不起眼的字符在 Lisp 中也是有意义的，例如单引号表达了后面的元素不进行执行而直接返回它本身：\n1\u0026#39;(Tom Amy John) 当括号前面有一个单引号时，表达了一个包含了三个元素的“数组”，而不是在执行一个叫 Tom 的函数。而\n1\u0026#39;ivy-set-prompt 表示把 ivy-set-prompt 这个函数作为一个对象传递给其它部分，也没有执行这个函数。\n反引号（`）backquote（或称 backtick、grave accent）在 Lisp 中也有含义，和单引号类似，读者只需要知道有这回事就好，基本上不需要我们去编写这些内容。 Emacs Lisp 源码文件的后缀名是 .el。\n分号（;）以后的内容都是注释。\n由于 Lisp 的整个语言结构就是列表的嵌套，所以它设定了一个非常强大的宏系统，可以用代码生成代码，甚至定义出一个与之前不太一样的新语言，常被称为方言。Emacs Lisp 就是这样诞生的。再加上其变量名可使用的字符很多，所以读者如果发现了一些不同寻常的写法，例如下文提到的 use-package，不要觉得惊讶，也请记住 Lisp 的语法本质始终都是列表。\n配置文件\n在介绍了 Emacs Lisp 的基本语法后，我们来正式开始学习 Emacs 的配置相关的知识。\n配置文件是一个包含了 Emacs Lisp 源码的文件，描述了 Emacs 应当以什么样的方式启动。在 Emacs 启动的时候会执行其中的代码，可以理解为启动时刻运行的脚本。\n当启动 Emacs 时，Emacs 会自动依次寻找以下几个文件之一作为配置文件：\n~/.emacs ~/.emacs.el ~/.emacs.d/init.el ~/.config/emacs/init.el 如果想用其它位置的自定义配置文件详见文档。 可以预见，随着我们需要的功能越来越复杂，配置源码会越来越长，我们会希望能够分多个源文件进行不同功能的管理。所以使用 ~/.emacs.d/init.el 作为配置文件是最为常见的。 我们可以将其它各种源文件都放置在 ~/.emacs.d 目录下，方便管理。\n基础设置 现成的配置 读者如果阅读过其它 Emacs 相关建议，一定见过很多人建议初学者直接使用一些 Emacs 大牛的配置。笔者的观点是大牛的配置自然要借鉴，但一定要慢慢学习大体了解其中的内容，不能盲目地使用，否则想要改配置的时候就不知所措了。\n笔者在最开始其实是完全自己配置的，虽然比较辛苦也走过很多弯路，但倒也是一个学习的过程。\n笔者最开始借鉴的就是 Steve Purcell 的配置。Steve Purcell 是 MELPA 的维护者（MELPA 是什么下文将会介绍）。读者可以 clone 下来后把文件夹命名为 ~/.emacs.d，之后启动 Emacs 时会自动安装 Steve Purcell 配好的插件。\n笔者作为一个代码强迫症患者，对于这种“不知道它给我安装了什么插件”的情况感到十分不快，所以我会进行自己的修改。之后的教程会尽可能介绍如何去配置、用到了什么插件。笔者会借鉴一部分 Steve Purcell 的配置来为大家讲解，读者可以在 Steve Purcell 的配置基础上自己修改，也可以从零开始一步步按照笔者的说明来进行探索。\n基本结构 首先，请使用 Emacs 打开 ~/.emacs.d/init.el 文件。一开始如果没有这个文件，我们创建它就好。\n根据 Emacs Lisp 的规范，所有的源码文件的开头最好写好 docstring，也就是一些关于这个文件的说明，即使是 init.el 也不例外。以 Steve Purcell 的 init.el 为例：\n1;;; init.el --- Load the full configuration -*- lexical-binding: t -*- 2;;; Commentary: 3 4;; This file bootstraps the configuration, which is divided into 5;; a number of other files. 6 7;;; Code: 按照习惯，三个分号开头的注释表示“节”，两个分号开头的注释表示“段落”。（一个分号开头的是一行代码后面的行内注释）。;;; Code: 后面就开始 Emacs Lisp 的代码了。同时，文件的结尾要是：\n1;;; init.el ends here Steve Purcell 的配置的前 34 行几乎可以照抄，除了其中一行 (require 'init-benchmarking)中使用了他定义在 ~/.emacs.d/lisp/init_benchmarking.el 中的逻辑来测量启动时间，读者酌情加入 ：\n1(let ((minver \u0026#34;25.1\u0026#34;)) 2 (when (version\u0026lt; emacs-version minver) 3 (error \u0026#34;Your Emacs is too old -- this config requires v%s or higher\u0026#34; minver))) 4(when (version\u0026lt; emacs-version \u0026#34;26.1\u0026#34;) 5 (message \u0026#34;Your Emacs is old, and some functionality in this config will be disabled. Please upgrade if possible.\u0026#34;)) 6 7(add-to-list \u0026#39;load-path (expand-file-name \u0026#34;lisp\u0026#34; user-emacs-directory)) ; 设定源码加载路径 8;; (require \u0026#39;init-benchmarking) ;; Measure startup time 9 10(defconst *spell-check-support-enabled* nil) ;; Enable with t if you prefer 11(defconst *is-a-mac* (eq system-type \u0026#39;darwin)) 12 13;; Adjust garbage collection thresholds during startup, and thereafter 14 15(let ((normal-gc-cons-threshold (* 20 1024 1024)) 16 (init-gc-cons-threshold (* 128 1024 1024))) 17 (setq gc-cons-threshold init-gc-cons-threshold) 18 (add-hook \u0026#39;emacs-startup-hook 19 (lambda () (setq gc-cons-threshold normal-gc-cons-threshold)))) 涉及一些基本的启动要素，例如检查版本、设定源码加载路径、通过修改垃圾回收的内存上限来提高 Emacs 启动速度等等。其中，“设定源码加载路径” 这句代码是指将 ~/.emacs.d/lisp/ 目录作为源码加载路径，这样你可以将功能需求拆分成多个文件放置在这个目录中，供 init.el 使用。\n那么拆分出去的功能怎么使用呢？如果你使用的是 Steve Purcell 的配置，可以看到许多的 (require 'xxx)，这个可以理解为“导入并执行”，基本类似于 Python 的 import。 也就是导入刚刚说的放置在了 ~/.emacs.d/lisp/ 目录下的某个源码文件，并运行了其中的代码使得内部的设置和函数定义生效。\n举个例子，我们可以创建一个文件 ~/.emacs.d/lisp/hello.el，包含如下代码：\n1;;; hello -- Echo \u0026#34;Hello, world!\u0026#34; 2;;; Commentary: 3;;; Code: 4 5(defun hello-world () 6 (interactive) 7 (message \u0026#34;Hello, world!\u0026#34;)) 8 9(provide \u0026#39;hello) ; 意为“导出本模块，名为 hello”。这样就可以在其它地方进行 require 10 11;;; hello.el ends here 在 init.el 中，加上一句代码 (require 'hello)，重启 Emacs，此时 Emacs 就会多了一条名为 hello-world 的命令。读者此时可以按下 M-x，输入 hello-world，就可以看到回显区 Echo area 中出现了 \u0026quot;Hello, world!\u0026quot;。尽管这个函数不在 init.el 中定义，但通过这种方式导入就可以顺利执行成功！\n观察 Steve Purcell 的 init.el，几乎通篇都是 (require 'xxx)，这种模块化风格值得学习。\n最开始的配置 对于一个刚打开的“白板”编辑器来说，有不少功能是我们亟需开启的，在此做简要归纳：\n1(setq confirm-kill-emacs #\u0026#39;yes-or-no-p) ; 在关闭 Emacs 前询问是否确认关闭，防止误触 2(electric-pair-mode t) ; 自动补全括号 3(add-hook \u0026#39;prog-mode-hook #\u0026#39;show-paren-mode) ; 编程模式下，光标在括号上时高亮另一个括号 4(column-number-mode t) ; 在 Mode line 上显示列号 5(global-auto-revert-mode t) ; 当另一程序修改了文件时，让 Emacs 及时刷新 Buffer 6(delete-selection-mode t) ; 选中文本后输入文本会替换文本（更符合我们习惯了的其它编辑器的逻辑） 7(setq inhibit-startup-message t) ; 关闭启动 Emacs 时的欢迎界面 8(setq make-backup-files nil) ; 关闭文件自动备份 9(add-hook \u0026#39;prog-mode-hook #\u0026#39;hs-minor-mode) ; 编程模式下，可以折叠代码块 10(global-display-line-numbers-mode 1) ; 在 Window 显示行号 11(tool-bar-mode -1) ; （熟练后可选）关闭 Tool bar 12(when (display-graphic-p) (toggle-scroll-bar -1)) ; 图形界面时关闭滚动条 13 14(savehist-mode 1) ; （可选）打开 Buffer 历史记录保存 15(setq display-line-numbers-type \u0026#39;relative) ; （可选）显示相对行号 16(add-to-list \u0026#39;default-frame-alist \u0026#39;(width . 90)) ; （可选）设定启动图形界面时的初始 Frame 宽度（字符数） 17(add-to-list \u0026#39;default-frame-alist \u0026#39;(height . 55)) ; （可选）设定启动图形界面时的初始 Frame 高度（字符数） 配置快捷键 首先介绍一下如何配置全局的快捷键：\n1(global-set-key (kbd \u0026lt;KEY\u0026gt;) \u0026lt;FUNCTION\u0026gt;) 其中 \u0026lt;KEY\u0026gt; 和 \u0026lt;FUNCTION\u0026gt; 替换为你想要设置的快捷键和功能。例如一个常见设置是修改回车键为“新起一行并做缩进”：\n1(global-set-key (kbd \u0026#34;RET\u0026#34;) \u0026#39;newline-and-indent) 其它设置示例：\n1(global-set-key (kbd \u0026#34;M-w\u0026#34;) \u0026#39;kill-region) ; 交换 M-w 和 C-w，M-w 为剪切 2(global-set-key (kbd \u0026#34;C-w\u0026#34;) \u0026#39;kill-ring-save) ; 交换 M-w 和 C-w，C-w 为复制 3(global-set-key (kbd \u0026#34;C-a\u0026#34;) \u0026#39;back-to-indentation) ; 交换 C-a 和 M-m，C-a 为到缩进后的行首 4(global-set-key (kbd \u0026#34;M-m\u0026#34;) \u0026#39;move-beginning-of-line) ; 交换 C-a 和 M-m，M-m 为到真正的行首 5(global-set-key (kbd \u0026#34;C-c \u0026#39;\u0026#34;) \u0026#39;comment-or-uncomment-region) ; 为选中的代码加注释/去注释 6 7;; 自定义两个函数 8;; Faster move cursor 9(defun next-ten-lines() 10 \u0026#34;Move cursor to next 10 lines.\u0026#34; 11 (interactive) 12 (next-line 10)) 13 14(defun previous-ten-lines() 15 \u0026#34;Move cursor to previous 10 lines.\u0026#34; 16 (interactive) 17 (previous-line 10)) 18;; 绑定到快捷键 19(global-set-key (kbd \u0026#34;M-n\u0026#34;) \u0026#39;next-ten-lines) ; 光标向下移动 10 行 20(global-set-key (kbd \u0026#34;M-p\u0026#34;) \u0026#39;previous-ten-lines) ; 光标向上移动 10 行 读者使用 Emacs 期间应当已经发现规律，Emacs 的常见快捷键前缀是 C-x 和 C-c，笔者有一些个人操作：解绑本来的 C-j 快捷键（本来功能为 electric-newline-and-maybe-indent），让 C-j 也成为了一个前缀：\n1(global-set-key (kbd \u0026#34;C-j\u0026#34;) nil) 2;; 删去光标所在行（在图形界面时可以用 \u0026#34;C-S-\u0026lt;DEL\u0026gt;\u0026#34;，终端常会拦截这个按法) 3(global-set-key (kbd \u0026#34;C-j C-k\u0026#34;) \u0026#39;kill-whole-line) MELPA 那么插件从哪里安装呢？Emacs 的插件都被放在了一些固定的仓库网站上，就好像手机的应用商店一样，区别是 Emacs 所使用的仓库是可以自由配置的，我们只需要把仓库的地址告诉 Emacs 就可以了。Emacs 最大的插件仓库就是 MELPA 了，也就是上文提到的 Steve Purcell 所维护的项目。此外也有一个默认仓库 GNU ELPA。\nMELPA 的官网有直接介绍如何配置：\n1(require \u0026#39;package) 2(add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) t) 3(package-initialize) 只需这三行，就可以把仓库地址 https://melpa.org/packages/ 存储到 package-archives 列表中，并命名为 “melpa”。\n由于国内网络问题，直接访问速度较慢，有如下两个方案。\n使用代理 把下面的代码加在配置文件中，修改为自己的代理服务器 IP 和代理服务器端口号。\n1(setq gnutls-algorithm-priority \u0026#34;NORMAL:-VERS-TLS1.3\u0026#34;) ; 不加这一句可能有问题，建议读者尝试一下 2(setq url-proxy-services \u0026#39;((\u0026#34;no_proxy\u0026#34; . \u0026#34;^\\\\(192\\\\.168\\\\..*\\\\)\u0026#34;) 3 (\u0026#34;http\u0026#34; . \u0026#34;\u0026lt;代理 IP\u0026gt;:\u0026lt;代理端口号\u0026gt;\u0026#34;) 4\t(\u0026#34;https\u0026#34; . \u0026#34;\u0026lt;代理 IP\u0026gt;:\u0026lt;代理端口号\u0026gt;\u0026#34;))) 使用国内镜像 腾讯镜像：\n1(require \u0026#39;package) 2(setq package-archives \u0026#39;((\u0026#34;gnu\u0026#34; . \u0026#34;http://mirrors.cloud.tencent.com/elpa/gnu/\u0026#34;) 3 (\u0026#34;melpa\u0026#34; . \u0026#34;http://mirrors.cloud.tencent.com/elpa/melpa/\u0026#34;))) 4(package-initialize) 腾讯镜像中，除了 MELPA，第一条的 \u0026quot;gnu\u0026quot; 对应着的就是默认的 GNU ELPA，部分包是只在 GNU ELPA 上 的。这里的配置意为：设置了两个插件仓库，一个叫 gnu，一个叫 melpa。 随后重启 Emacs 后，输入命令 package-list-packages 就可以列出来仓库中的所有插件，可以选中相应的插件，会弹出介绍的界面和安装按钮。此外，还可以直接通过命令 package-install ，按下回车后，输入插件名就可以安装相应插件。\npackage-list-packages 列表界面下，可以按 h 显示帮助。在这个视图下可以批量操作，类似 Buffer List。例如可以按 U 检查所有已安装插件是否有新版本，如果有就会标注更新。按 i 可以标记想要安装。最后按下 x 就可以执行更新操作。 默认情况下，插件会被安装到 ~/.emacs.d/elpa/ 目录下。\n想要删除已安装的插件，输入命令 package-delete ，然后输入已安装的插件名即可。\n插件设置 (use-package) 通常各种插件都会发布到 GitHub 上，一般在上面都会介绍如何配置这个插件。但插件逐渐多了我们会发现，不同插件的使用、配置常常不同，一一配置会使得配置文件很乱，且不易管理，并且缺少一些自动化的配置机制。Steve Purcell 的配置中，他在 init-elpa.el 中定义了一些辅助函数 require-package 等实现了插件的自动安装。\n笔者则使用了一个更为方便的插件 use-package 来进行管理。\n首先安装 use-package。输入命令 package-install 按下回车后输入 \u0026quot;use-package\u0026quot;，回车。在 init.el 较靠前的位置（或其它你认为合适的文件中）写上：\n1(eval-when-compile 2 (require \u0026#39;use-package)) 这样，我们就在启动 Emacs 的时候首先加载 use-package 插件。随后我们再使用 use-package 插件来管理所有其它插件。\nuse-package 官网提供了一些教程，其使用方法很简单，假设我们希望使用一个叫 foo 的插件：\n1(use-package foo 2 :init ; 在加载插件前执行一些命令 3 (setq foo-variable t) 4 :config ; 在加载插件后执行一些命令 5 (foo-mode 1)) 所有的冒号开头的词是 use-package 的一些设置关键词。上面的代码表示使用名为 foo 的插件，在加载插件之前设置变量 foo-variable 为 t （即 true）。并在加载之后启动 foo-mode 。\n例如，我们在后面会介绍的一个 Emacs 补全功能增强插件 ivy，只需编写如下配置（这里只是示例，单纯粘贴此段代码会有报错，请查看后面的教程中更详细的说明）：\n1(use-package ivy 2 :ensure t ; 确认安装，如果没有安装过 ivy 就自动安装 3 :config ; 在加载插件后执行一些命令 4 (ivy-mode 1) ; 加载后启动 ivy-mode 5 (setq ivy-use-virtual-buffers t) ; 一些官网提供的固定配置 6 (setq ivy-count-format \u0026#34;(%d/%d) \u0026#34;) 7 :bind ; 以下为绑定快捷键 8 (\u0026#34;C-s\u0026#34; . \u0026#39;swiper-isearch) ; 绑定快捷键 C-s 为 swiper-search，替换原本的搜索功能 9 (\u0026#34;M-x\u0026#34; . \u0026#39;counsel-M-x) ; 使用 counsel 替换命令输入，给予更多提示 10 (\u0026#34;C-x C-f\u0026#34; . \u0026#39;counsel-find-file) ; 使用 counsel 做文件打开操作，给予更多提示 11 (\u0026#34;M-y\u0026#34; . \u0026#39;counsel-yank-pop) ; 使用 counsel 做历史剪贴板粘贴，可以展示历史 12 (\u0026#34;C-x b\u0026#34; . \u0026#39;ivy-switch-buffer) ; 使用 ivy 做 buffer 切换，给予更多提示 13 (\u0026#34;C-c v\u0026#34; . \u0026#39;ivy-push-view) ; 记录当前 buffer 的信息 14 (\u0026#34;C-c s\u0026#34; . \u0026#39;ivy-switch-view) ; 切换到记录过的 buffer 位置 15 (\u0026#34;C-c V\u0026#34; . \u0026#39;ivy-pop-view) ; 移除 buffer 记录 16 (\u0026#34;C-x C-SPC\u0026#34; . \u0026#39;counsel-mark-ring) ; 使用 counsel 记录 mark 的位置 17 (\u0026#34;\u0026lt;f1\u0026gt; f\u0026#34; . \u0026#39;counsel-describe-function) 18 (\u0026#34;\u0026lt;f1\u0026gt; v\u0026#34; . \u0026#39;counsel-describe-variable) 19 (\u0026#34;\u0026lt;f1\u0026gt; i\u0026#34; . \u0026#39;counsel-info-lookup-symbol)) 这样，所有有关 ivy 插件的配置就都整合在了一个 (use-package ...) 中，并且只需要加上 :ensure t 就可以检查安装情况、自动安装，十分方便管理。\n这里出现的语法看似和我们之前了解的不同，但其实本质一样。虽然 :ensure、:bind 等写法看起来好像很奇怪，但正如我们上文学到的，Lisp 的变量名十分灵活，且语言特性使得它具有非常强大的宏，可以自定义一些语法。use-package 就是自己设定了这样的一种写法。 此外，也可以轻松地设定上一篇教程中提到的模式的 hook。例如，我们希望在编程模式 prog-mode 下使用代码语法检查工具 flycheck，只需要使用 :hook 进行设置：\n1(use-package flycheck 2 :ensure t 3 :hook ; 为模式设置 hook 4 (prog-mode . flycheck-mode)) 配置变量 除了使用配置文件，Emacs 还提供了一个更为方便的办法管理一些变量（customizable variables），或称用户选项（user options）。\n最简单的进入办法，就是按下 M-x 输入 customize 后回车确认。\n变量是分组（group）管理的，只需要点进去寻找或搜索相关的变量就可以进行设置。对于每一个变量，点左侧的箭头展开内容，可以看到有的变量是 Toggle 按钮表示可以设定 true/false，有的则是取值列表，可以设定值。修改后，State 会显示已编辑。最后点击上方的 Apply 就是应用更改。点击 Revert 就可以放弃更改等。按 q 退出。\n当设置了变量后，事实上 Emacs 会自动将一些配置代码加入到 init.el 中，或是加入到自定义的文件中（比如 Steve Purcell 就自定义了这个文件）。\n此外，使用 Emacs 的过程中也可以临时修改某个变量的值，M-x set-variable 就可以输入变量名、回车、输入值、回车。还可以用 C-h v 输入变量名来查看变量的含义。\n因此总结来说，想要设定变量有三种途径：\n配置文件中使用 (setq name value) customize 中设定 运行过程中临时修改 M-x set-variable 最后笔者还想再强调一下，一定要区分好命令和变量 。这里笔者所指的”命令“是带有 (interactive) 的函数。例如上文举例的 hello-world 函数，这种函数可以通过 M-x 输入函数名调用，本教程姑且称之为“命令“。命令是可以执行的，而变量只是保存一个值，是不可执行的。在 Emacs Lisp 中二者的命名规则是一致的，看起来十分相似，对于初学者容易混淆。\n配置生效 最简单让配置生效的办法就是重启 Emacs。\n此外，如果你在频繁的改一些配置，尤其是调整一些参数等，频繁的重启很麻烦。事实上 Emacs Lisp 语言是逐句执行的。所以例如我们新加入了一段配置，我们便可以直接选中这部分代码，然后按下 M-x eval-region ，表达了“运行选中的这部分代码”的含义，这样这段代码立刻就会生效了。当然，还有 M-x eval-buffer 可以直接重新执行一下当前 Buffer 的所有代码。\n结尾 最后，配置文件的结尾要有一句：\n1(provide \u0026#39;init) 2 3;;; init.el ends here ","link":"https://pavinberg.github.io/emacs-book/zh/configuration/","section":"","title":"基本配置"},{"body":"To be edited...\n","link":"https://pavinberg.github.io/emacs-book/zh/optimization/","section":"","title":"插件：功能优化类"},{"body":"To be edited...\n","link":"https://pavinberg.github.io/emacs-book/zh/enhancement/","section":"","title":"插件：功能增强类"},{"body":"To be edited...\n","link":"https://pavinberg.github.io/emacs-book/zh/development/","section":"","title":"插件：编程开发类"},{"body":"赞赏本篇教程 ","link":"https://pavinberg.github.io/emacs-book/zh/donate/","section":"donate","title":""},{"body":"","link":"https://pavinberg.github.io/emacs-book/zh/categories/","section":"categories","title":"Categories"},{"body":"","link":"https://pavinberg.github.io/emacs-book/zh/tags/","section":"tags","title":"Tags"}]